# TerraFE è„šæ‰‹æ¶å¼€å‘å®æˆ˜ç³»åˆ—ï¼ˆäº”ï¼‰ï¼šæ–‡ä»¶æ“ä½œä¸é¡¹ç›®ç”Ÿæˆ

## å‰è¨€

é¡¹ç›®ç”Ÿæˆæ˜¯è„šæ‰‹æ¶å·¥å…·çš„æœ€ç»ˆç›®æ ‡ï¼Œæ¶‰åŠæ–‡ä»¶ç³»ç»Ÿæ“ä½œã€æƒé™å¤„ç†ã€ä¾èµ–å®‰è£…ç­‰å¤æ‚æµç¨‹ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç» TerraFE çš„é¡¹ç›®ç”Ÿæˆå™¨å®ç°ï¼ŒåŒ…æ‹¬å®Œæ•´çš„æ–‡ä»¶æ“ä½œæµç¨‹å’Œåå¤„ç†ç³»ç»Ÿã€‚

## é¡¹ç›®ç”Ÿæˆå™¨æ¶æ„

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

```
ProjectGenerator
â”œâ”€â”€ FileGenerator     # æ–‡ä»¶ç”Ÿæˆå™¨
â”œâ”€â”€ DependencyManager # ä¾èµ–ç®¡ç†å™¨  
â”œâ”€â”€ GitManager        # Git ç®¡ç†å™¨
â”œâ”€â”€ PostProcessor     # åå¤„ç†å™¨
â”œâ”€â”€ HookManager       # é’©å­ç®¡ç†å™¨
â””â”€â”€ ValidationEngine  # éªŒè¯å¼•æ“
```

### ç”Ÿæˆæµç¨‹è®¾è®¡

```
1. é¢„å¤„ç†éªŒè¯
2. åˆ›å»ºé¡¹ç›®ç›®å½•
3. ç”Ÿæˆé¡¹ç›®æ–‡ä»¶
4. å¤„ç†æ–‡ä»¶æƒé™
5. å®‰è£…ä¾èµ–
6. åˆå§‹åŒ– Git
7. æ‰§è¡Œåå¤„ç†é’©å­
8. ç”Ÿæˆå®ŒæˆæŠ¥å‘Š
```

## é¡¹ç›®ç”Ÿæˆå™¨æ ¸å¿ƒå®ç°

```javascript
// lib/core/Generator.js
import { resolve, join, dirname } from 'path';
import { existsSync } from 'fs';
import { mkdir, writeFile, chmod, readdir, stat } from 'fs/promises';

import logger from '../utils/logger.js';
import { ProgressManager } from '../utils/progress.js';
import TemplateManager from './TemplateManager.js';
import VariableEngine from './VariableEngine.js';
import FileGenerator from './FileGenerator.js';
import DependencyManager from './DependencyManager.js';
import GitManager from './GitManager.js';
import PostProcessor from './PostProcessor.js';

export default class Generator {
  constructor(projectName, options = {}) {
    this.projectName = projectName;
    this.options = options;
    this.targetDir = resolve(projectName);
    
    // åˆå§‹åŒ–å„ä¸ªç®¡ç†å™¨
    this.templateManager = new TemplateManager();
    this.variableEngine = new VariableEngine();
    this.fileGenerator = new FileGenerator();
    this.dependencyManager = new DependencyManager();
    this.gitManager = new GitManager();
    this.postProcessor = new PostProcessor();
    
    this.progress = new ProgressManager();
  }

  /**
   * ç”Ÿæˆé¡¹ç›®
   */
  async generate() {
    const steps = [
      { name: 'éªŒè¯é¡¹ç›®é…ç½®', method: 'validateProject' },
      { name: 'è·å–æ¨¡æ¿', method: 'getTemplate' },
      { name: 'å¤„ç†æ¨¡æ¿å˜é‡', method: 'processTemplateVariables' },
      { name: 'åˆ›å»ºé¡¹ç›®ç›®å½•', method: 'createProjectDirectory' },
      { name: 'ç”Ÿæˆé¡¹ç›®æ–‡ä»¶', method: 'generateProjectFiles' },
      { name: 'å®‰è£…ä¾èµ–', method: 'installDependencies' },
      { name: 'åˆå§‹åŒ– Git', method: 'initializeGit' },
      { name: 'æ‰§è¡Œåå¤„ç†', method: 'runPostProcessing' }
    ];

    this.progress.setSteps(steps);

    try {
      await this.templateManager.initialize();
      
      for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        
        this.progress.updateStep(i, 'running');
        await this[step.method]();
        this.progress.updateStep(i, 'completed');
      }

      this.progress.succeed(`é¡¹ç›® ${this.projectName} åˆ›å»ºæˆåŠŸï¼`);
      await this.showCompletionSummary();

    } catch (error) {
      this.progress.fail(`é¡¹ç›®åˆ›å»ºå¤±è´¥: ${error.message}`);
      throw error;
    }
  }

  /**
   * éªŒè¯é¡¹ç›®é…ç½®
   */
  async validateProject() {
    // éªŒè¯é¡¹ç›®åç§°
    const nameValidation = validateProjectName(this.projectName);
    if (!nameValidation.valid) {
      throw new Error(`é¡¹ç›®åç§°æ— æ•ˆ: ${nameValidation.errors.join(', ')}`);
    }

    // æ£€æŸ¥ç›®æ ‡ç›®å½•
    if (existsSync(this.targetDir)) {
      if (!this.options.force) {
        throw new Error(`ç›®å½• ${this.projectName} å·²å­˜åœ¨`);
      }
      
      // å¦‚æœæ˜¯å¼ºåˆ¶æ¨¡å¼ï¼Œæ£€æŸ¥ç›®å½•æ˜¯å¦å¯å†™
      const stats = await stat(this.targetDir);
      if (!stats.isDirectory()) {
        throw new Error(`${this.projectName} å·²å­˜åœ¨ä¸”ä¸æ˜¯ç›®å½•`);
      }
    }

    // éªŒè¯æ¨¡æ¿é€‰é¡¹
    if (this.options.template && this.options.repo) {
      throw new Error('ä¸èƒ½åŒæ—¶æŒ‡å®š template å’Œ repo é€‰é¡¹');
    }
  }

  /**
   * è·å–æ¨¡æ¿
   */
  async getTemplate() {
    let templateId;

    if (this.options.template) {
      templateId = this.options.template;
    } else if (this.options.repo) {
      templateId = this.options.repo;
    } else if (this.options.localPath) {
      templateId = this.options.localPath;
    } else {
      // ä½¿ç”¨é»˜è®¤æ¨¡æ¿
      templateId = 'vanilla-ts';
    }

    this.template = await this.templateManager.getTemplate(templateId, {
      force: this.options.force
    });

    logger.debug('æ¨¡æ¿è·å–æˆåŠŸ:', templateId);
  }

  /**
   * å¤„ç†æ¨¡æ¿å˜é‡
   */
  async processTemplateVariables() {
    const variables = this.buildTemplateVariables();
    
    this.processedTemplate = this.variableEngine.processTemplate(
      this.template,
      variables
    );

    logger.debug('æ¨¡æ¿å˜é‡å¤„ç†å®Œæˆ');
  }

  /**
   * åˆ›å»ºé¡¹ç›®ç›®å½•
   */
  async createProjectDirectory() {
    if (existsSync(this.targetDir) && this.options.force) {
      // æ¸…ç©ºç›®å½•å†…å®¹ï¼ˆä¿ç•™ç›®å½•æœ¬èº«ï¼‰
      await this.clearDirectory(this.targetDir);
    } else {
      await mkdir(this.targetDir, { recursive: true });
    }

    logger.debug('é¡¹ç›®ç›®å½•åˆ›å»ºå®Œæˆ:', this.targetDir);
  }

  /**
   * ç”Ÿæˆé¡¹ç›®æ–‡ä»¶
   */
  async generateProjectFiles() {
    await this.fileGenerator.generateFiles(
      this.processedTemplate,
      this.targetDir,
      {
        preserveMode: true,
        createDirectories: true,
        validateFiles: true
      }
    );

    logger.debug('é¡¹ç›®æ–‡ä»¶ç”Ÿæˆå®Œæˆ');
  }

  /**
   * å®‰è£…ä¾èµ–
   */
  async installDependencies() {
    if (this.options.skipInstall || !this.options.installDeps) {
      logger.debug('è·³è¿‡ä¾èµ–å®‰è£…');
      return;
    }

    const packageManager = this.options.packageManager || 'npm';
    
    await this.dependencyManager.install(this.targetDir, {
      packageManager,
      verbose: this.options.verbose
    });

    logger.debug('ä¾èµ–å®‰è£…å®Œæˆ');
  }

  /**
   * åˆå§‹åŒ– Git
   */
  async initializeGit() {
    if (this.options.skipGit || !this.options.initGit) {
      logger.debug('è·³è¿‡ Git åˆå§‹åŒ–');
      return;
    }

    await this.gitManager.initialize(this.targetDir, {
      initialCommit: this.options.initialCommit,
      commitMessage: `feat: initial commit by TerraFE`
    });

    logger.debug('Git åˆå§‹åŒ–å®Œæˆ');
  }

  /**
   * æ‰§è¡Œåå¤„ç†
   */
  async runPostProcessing() {
    if (!this.template.config || !this.template.config.hooks) {
      return;
    }

    await this.postProcessor.run(
      this.template.config.hooks,
      this.targetDir,
      this.buildTemplateVariables()
    );

    logger.debug('åå¤„ç†æ‰§è¡Œå®Œæˆ');
  }

  /**
   * æ„å»ºæ¨¡æ¿å˜é‡
   */
  buildTemplateVariables() {
    return {
      projectName: this.projectName,
      description: this.options.description || `A project created with TerraFE`,
      author: this.options.author || 'Anonymous',
      version: this.options.version || '1.0.0',
      license: this.options.license || 'MIT',
      packageManager: this.options.packageManager || 'npm',
      
      // æ¡†æ¶ç›¸å…³
      framework: this.options.framework || 'vanilla',
      typescript: this.options.typescript || false,
      cssPreprocessor: this.options.cssPreprocessor || 'none',
      
      // å·¥å…·ç›¸å…³
      tools: this.options.tools || [],
      
      // æ—¶é—´ç›¸å…³
      currentYear: new Date().getFullYear(),
      currentDate: new Date().toISOString().split('T')[0],
      
      // è·¯å¾„ç›¸å…³
      projectDir: this.targetDir,
      
      // è‡ªå®šä¹‰å˜é‡
      ...this.options.variables
    };
  }

  /**
   * æ¸…ç©ºç›®å½•
   */
  async clearDirectory(dir) {
    const items = await readdir(dir);
    
    for (const item of items) {
      const itemPath = join(dir, item);
      await rm(itemPath, { recursive: true, force: true });
    }
  }

  /**
   * æ˜¾ç¤ºå®Œæˆæ‘˜è¦
   */
  async showCompletionSummary() {
    console.log();
    logger.success('ğŸ‰ é¡¹ç›®åˆ›å»ºå®Œæˆï¼');
    console.log();
    
    // æ˜¾ç¤ºé¡¹ç›®ä¿¡æ¯
    console.log(chalk.bold('é¡¹ç›®ä¿¡æ¯:'));
    console.log(`  åç§°: ${chalk.cyan(this.projectName)}`);
    console.log(`  è·¯å¾„: ${chalk.gray(this.targetDir)}`);
    console.log(`  æ¨¡æ¿: ${chalk.gray(this.getTemplateDisplayName())}`);
    console.log();

    // æ˜¾ç¤ºåç»­æ­¥éª¤
    console.log(chalk.bold('åç»­æ­¥éª¤:'));
    console.log(`  ${chalk.gray('cd')} ${this.projectName}`);
    
    if (!this.options.installDeps) {
      const pm = this.options.packageManager || 'npm';
      console.log(`  ${chalk.gray(pm)} install`);
    }
    
    console.log(`  ${chalk.gray('npm')} run dev`);
    console.log();

    // æ˜¾ç¤ºæœ‰ç”¨çš„å‘½ä»¤
    if (this.template.config && this.template.config.commands) {
      console.log(chalk.bold('å¯ç”¨å‘½ä»¤:'));
      for (const [name, desc] of Object.entries(this.template.config.commands)) {
        console.log(`  ${chalk.gray(name)}: ${desc}`);
      }
      console.log();
    }

    // æ˜¾ç¤ºæ–‡æ¡£é“¾æ¥
    if (this.template.config && this.template.config.documentation) {
      console.log(chalk.bold('ç›¸å…³æ–‡æ¡£:'));
      for (const [name, url] of Object.entries(this.template.config.documentation)) {
        console.log(`  ${name}: ${chalk.blue(url)}`);
      }
      console.log();
    }
  }

  /**
   * è·å–æ¨¡æ¿æ˜¾ç¤ºåç§°
   */
  getTemplateDisplayName() {
    if (this.options.template) {
      return `å®˜æ–¹æ¨¡æ¿: ${this.options.template}`;
    } else if (this.options.repo) {
      return `GitHub: ${this.options.repo}`;
    } else if (this.options.localPath) {
      return `æœ¬åœ°: ${this.options.localPath}`;
    }
    return 'é»˜è®¤æ¨¡æ¿';
  }
}
```

## æ–‡ä»¶ç”Ÿæˆå™¨å®ç°

```javascript
// lib/core/FileGenerator.js
import { join, dirname } from 'path';
import { mkdir, writeFile, chmod } from 'fs/promises';

import logger from '../utils/logger.js';

export default class FileGenerator {
  /**
   * ç”Ÿæˆæ‰€æœ‰æ–‡ä»¶
   */
  async generateFiles(template, targetDir, options = {}) {
    const {
      preserveMode = true,
      createDirectories = true,
      validateFiles = true
    } = options;

    for (const [filePath, fileInfo] of template.files) {
      await this.generateFile(
        filePath,
        fileInfo,
        targetDir,
        { preserveMode, createDirectories, validateFiles }
      );
    }
  }

  /**
   * ç”Ÿæˆå•ä¸ªæ–‡ä»¶
   */
  async generateFile(filePath, fileInfo, targetDir, options) {
    const fullPath = join(targetDir, filePath);
    const dir = dirname(fullPath);

    // åˆ›å»ºç›®å½•
    if (options.createDirectories) {
      await mkdir(dir, { recursive: true });
    }

    // å†™å…¥æ–‡ä»¶å†…å®¹
    if (fileInfo.content !== null) {
      await writeFile(fullPath, fileInfo.content);
      
      // è®¾ç½®æ–‡ä»¶æƒé™
      if (options.preserveMode && fileInfo.mode) {
        await chmod(fullPath, fileInfo.mode);
      }
    }

    // éªŒè¯æ–‡ä»¶
    if (options.validateFiles) {
      await this.validateGeneratedFile(fullPath, fileInfo);
    }

    logger.debug(`ç”Ÿæˆæ–‡ä»¶: ${filePath}`);
  }

  /**
   * éªŒè¯ç”Ÿæˆçš„æ–‡ä»¶
   */
  async validateGeneratedFile(filePath, expectedInfo) {
    try {
      const stats = await stat(filePath);
      
      // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆå…è®¸ä¸€å®šå·®å¼‚ï¼Œå› ä¸ºå˜é‡æ›¿æ¢å¯èƒ½æ”¹å˜å¤§å°ï¼‰
      if (expectedInfo.size && Math.abs(stats.size - expectedInfo.size) > 1000) {
        logger.warn(`æ–‡ä»¶å¤§å°å·®å¼‚è¾ƒå¤§: ${filePath}`);
      }
      
      return true;
    } catch (error) {
      throw new Error(`æ–‡ä»¶éªŒè¯å¤±è´¥ ${filePath}: ${error.message}`);
    }
  }

  /**
   * æ‰¹é‡åˆ›å»ºç›®å½•ç»“æ„
   */
  async createDirectoryStructure(structure, baseDir) {
    for (const dirPath of structure) {
      const fullPath = join(baseDir, dirPath);
      await mkdir(fullPath, { recursive: true });
    }
  }

  /**
   * å¤åˆ¶æ–‡ä»¶ï¼ˆç”¨äºäºŒè¿›åˆ¶æ–‡ä»¶ï¼‰
   */
  async copyBinaryFile(sourcePath, targetPath) {
    const targetDir = dirname(targetPath);
    await mkdir(targetDir, { recursive: true });
    
    await copyFile(sourcePath, targetPath);
    
    // ä¿æŒåŸæ–‡ä»¶æƒé™
    const sourceStats = await stat(sourcePath);
    await chmod(targetPath, sourceStats.mode);
  }
}
```

## ä¾èµ–ç®¡ç†å™¨å®ç°

```javascript
// lib/core/DependencyManager.js
import { spawn } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';

import logger from '../utils/logger.js';
import { ProgressManager } from '../utils/progress.js';

export default class DependencyManager {
  constructor() {
    this.progress = new ProgressManager();
  }

  /**
   * å®‰è£…ä¾èµ–
   */
  async install(projectDir, options = {}) {
    const { packageManager = 'npm', verbose = false } = options;

    // æ£€æŸ¥ package.json æ˜¯å¦å­˜åœ¨
    const packageJsonPath = join(projectDir, 'package.json');
    if (!existsSync(packageJsonPath)) {
      throw new Error('package.json æ–‡ä»¶ä¸å­˜åœ¨');
    }

    // æ£€æµ‹åŒ…ç®¡ç†å™¨æ˜¯å¦å¯ç”¨
    await this.validatePackageManager(packageManager);

    this.progress.start(`ä½¿ç”¨ ${packageManager} å®‰è£…ä¾èµ–...`);

    try {
      await this.runInstallCommand(packageManager, projectDir, verbose);
      this.progress.succeed('ä¾èµ–å®‰è£…å®Œæˆ');
    } catch (error) {
      this.progress.fail('ä¾èµ–å®‰è£…å¤±è´¥');
      throw error;
    }
  }

  /**
   * éªŒè¯åŒ…ç®¡ç†å™¨
   */
  async validatePackageManager(packageManager) {
    try {
      await this.execCommand(packageManager, ['--version']);
    } catch (error) {
      throw new Error(`åŒ…ç®¡ç†å™¨ ${packageManager} ä¸å¯ç”¨`);
    }
  }

  /**
   * è¿è¡Œå®‰è£…å‘½ä»¤
   */
  async runInstallCommand(packageManager, projectDir, verbose) {
    const commands = {
      npm: ['install'],
      yarn: ['install'],
      pnpm: ['install']
    };

    const args = commands[packageManager];
    if (!args) {
      throw new Error(`ä¸æ”¯æŒçš„åŒ…ç®¡ç†å™¨: ${packageManager}`);
    }

    // æ·»åŠ é™é»˜é€‰é¡¹ï¼ˆé verbose æ¨¡å¼ï¼‰
    if (!verbose) {
      if (packageManager === 'npm') {
        args.push('--silent');
      } else if (packageManager === 'yarn') {
        args.push('--silent');
      } else if (packageManager === 'pnpm') {
        args.push('--reporter=silent');
      }
    }

    await this.execCommand(packageManager, args, {
      cwd: projectDir,
      stdio: verbose ? 'inherit' : 'ignore'
    });
  }

  /**
   * æ·»åŠ ä¾èµ–
   */
  async addDependency(projectDir, packages, options = {}) {
    const {
      packageManager = 'npm',
      dev = false,
      exact = false
    } = options;

    const commands = {
      npm: ['install'],
      yarn: ['add'],
      pnpm: ['add']
    };

    const args = [...commands[packageManager]];
    
    if (dev) {
      if (packageManager === 'npm') {
        args.push('--save-dev');
      } else {
        args.push('--dev');
      }
    }

    if (exact) {
      if (packageManager === 'npm') {
        args.push('--save-exact');
      } else if (packageManager === 'yarn') {
        args.push('--exact');
      }
    }

    args.push(...packages);

    await this.execCommand(packageManager, args, { cwd: projectDir });
  }

  /**
   * æ‰§è¡Œå‘½ä»¤
   */
  async execCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args, {
        stdio: 'pipe',
        ...options
      });

      let stdout = '';
      let stderr = '';

      if (child.stdout) {
        child.stdout.on('data', (data) => {
          stdout += data.toString();
        });
      }

      if (child.stderr) {
        child.stderr.on('data', (data) => {
          stderr += data.toString();
        });
      }

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          reject(new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥ (é€€å‡ºç : ${code}): ${stderr || stdout}`));
        }
      });

      child.on('error', (error) => {
        reject(new Error(`å‘½ä»¤æ‰§è¡Œå‡ºé”™: ${error.message}`));
      });
    });
  }

  /**
   * æ£€æµ‹å¯ç”¨çš„åŒ…ç®¡ç†å™¨
   */
  async detectAvailablePackageManagers() {
    const managers = ['pnpm', 'yarn', 'npm'];
    const available = [];

    for (const manager of managers) {
      try {
        const result = await this.execCommand(manager, ['--version']);
        available.push({
          name: manager,
          version: result.stdout.trim()
        });
      } catch {
        // åŒ…ç®¡ç†å™¨ä¸å¯ç”¨
      }
    }

    return available;
  }

  /**
   * è·å–æ¨èçš„åŒ…ç®¡ç†å™¨
   */
  async getRecommendedPackageManager() {
    const available = await this.detectAvailablePackageManagers();
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    const priority = ['pnpm', 'yarn', 'npm'];
    
    for (const pm of priority) {
      if (available.find(a => a.name === pm)) {
        return pm;
      }
    }
    
    return 'npm'; // é»˜è®¤
  }
}
```

## Git ç®¡ç†å™¨å®ç°

```javascript
// lib/core/GitManager.js
import { spawn } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';

import logger from '../utils/logger.js';

export default class GitManager {
  /**
   * åˆå§‹åŒ– Git ä»“åº“
   */
  async initialize(projectDir, options = {}) {
    const {
      initialCommit = true,
      commitMessage = 'Initial commit'
    } = options;

    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ Git ä»“åº“
    const gitDir = join(projectDir, '.git');
    if (existsSync(gitDir)) {
      logger.warn('ç›®å½•å·²æ˜¯ Git ä»“åº“ï¼Œè·³è¿‡åˆå§‹åŒ–');
      return;
    }

    try {
      // åˆå§‹åŒ–ä»“åº“
      await this.execGitCommand(['init'], projectDir);
      logger.debug('Git ä»“åº“åˆå§‹åŒ–å®Œæˆ');

      // æ·»åŠ æ‰€æœ‰æ–‡ä»¶
      await this.execGitCommand(['add', '.'], projectDir);
      logger.debug('æ–‡ä»¶æ·»åŠ åˆ°æš‚å­˜åŒº');

      // åˆ›å»ºåˆå§‹æäº¤
      if (initialCommit) {
        await this.execGitCommand(['commit', '-m', commitMessage], projectDir);
        logger.debug('åˆå§‹æäº¤åˆ›å»ºå®Œæˆ');
      }

    } catch (error) {
      throw new Error(`Git åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * æ·»åŠ è¿œç¨‹ä»“åº“
   */
  async addRemote(projectDir, name, url) {
    try {
      await this.execGitCommand(['remote', 'add', name, url], projectDir);
      logger.debug(`è¿œç¨‹ä»“åº“ ${name} æ·»åŠ å®Œæˆ`);
    } catch (error) {
      throw new Error(`æ·»åŠ è¿œç¨‹ä»“åº“å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * åˆ›å»ºåˆ†æ”¯
   */
  async createBranch(projectDir, branchName) {
    try {
      await this.execGitCommand(['checkout', '-b', branchName], projectDir);
      logger.debug(`åˆ†æ”¯ ${branchName} åˆ›å»ºå®Œæˆ`);
    } catch (error) {
      throw new Error(`åˆ›å»ºåˆ†æ”¯å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * æ£€æŸ¥ Git æ˜¯å¦å¯ç”¨
   */
  async isGitAvailable() {
    try {
      await this.execGitCommand(['--version']);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * è·å– Git é…ç½®
   */
  async getGitConfig() {
    try {
      const nameResult = await this.execGitCommand(['config', 'user.name']);
      const emailResult = await this.execGitCommand(['config', 'user.email']);
      
      return {
        name: nameResult.stdout.trim(),
        email: emailResult.stdout.trim()
      };
    } catch {
      return { name: '', email: '' };
    }
  }

  /**
   * æ‰§è¡Œ Git å‘½ä»¤
   */
  async execGitCommand(args, cwd = process.cwd()) {
    return new Promise((resolve, reject) => {
      const child = spawn('git', args, {
        cwd,
        stdio: 'pipe'
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          reject(new Error(`Git å‘½ä»¤å¤±è´¥: ${stderr || stdout}`));
        }
      });

      child.on('error', (error) => {
        reject(new Error(`Git å‘½ä»¤æ‰§è¡Œå‡ºé”™: ${error.message}`));
      });
    });
  }
}
```

## æ€»ç»“

æœ¬æ–‡è¯¦ç»†ä»‹ç»äº† TerraFE é¡¹ç›®ç”Ÿæˆç³»ç»Ÿçš„å®Œæ•´å®ç°ï¼š

1. **é¡¹ç›®ç”Ÿæˆå™¨**ï¼šåè°ƒæ•´ä¸ªç”Ÿæˆæµç¨‹çš„æ ¸å¿ƒç»„ä»¶
2. **æ–‡ä»¶ç”Ÿæˆå™¨**ï¼šå¤„ç†æ–‡ä»¶ç³»ç»Ÿæ“ä½œå’Œæƒé™ç®¡ç†
3. **ä¾èµ–ç®¡ç†å™¨**ï¼šæ™ºèƒ½çš„åŒ…ç®¡ç†å™¨æ£€æµ‹å’Œä¾èµ–å®‰è£…
4. **Git ç®¡ç†å™¨**ï¼šå®Œæ•´çš„ Git ä»“åº“åˆå§‹åŒ–åŠŸèƒ½

è¿™å¥—ç³»ç»Ÿç¡®ä¿äº†é¡¹ç›®ç”Ÿæˆè¿‡ç¨‹çš„å¯é æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

## ä¸‹æœŸé¢„å‘Š

**ã€ŠTerraFE è„šæ‰‹æ¶å¼€å‘å®æˆ˜ç³»åˆ—ï¼ˆå…­ï¼‰ï¼šé”™è¯¯å¤„ç†ä¸ç”¨æˆ·ä½“éªŒä¼˜åŒ–ã€‹**

- å…¨å±€é”™è¯¯å¤„ç†ç­–ç•¥
- ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
- æ“ä½œæ¢å¤æœºåˆ¶
- æ€§èƒ½ä¼˜åŒ–æŠ€å·§

---

*å¦‚æœè¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµå’Œè½¬å‘ã€‚æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºè®¨è®ºï¼* 