# TerraFE 脚手架开发实战系列（五）：文件操作与项目生成

## 前言

项目生成是脚手架工具的最终目标，涉及文件系统操作、权限处理、依赖安装等复杂流程。本文将详细介绍 TerraFE 的项目生成器实现，包括完整的文件操作流程和后处理系统。

## 项目生成器架构

### 核心组件设计

```
ProjectGenerator
├── FileGenerator     # 文件生成器
├── DependencyManager # 依赖管理器  
├── GitManager        # Git 管理器
├── PostProcessor     # 后处理器
├── HookManager       # 钩子管理器
└── ValidationEngine  # 验证引擎
```

### 生成流程设计

```
1. 预处理验证
2. 创建项目目录
3. 生成项目文件
4. 处理文件权限
5. 安装依赖
6. 初始化 Git
7. 执行后处理钩子
8. 生成完成报告
```

## 项目生成器核心实现

```javascript
// lib/core/Generator.js
import { resolve, join, dirname } from 'path';
import { existsSync } from 'fs';
import { mkdir, writeFile, chmod, readdir, stat } from 'fs/promises';

import logger from '../utils/logger.js';
import { ProgressManager } from '../utils/progress.js';
import TemplateManager from './TemplateManager.js';
import VariableEngine from './VariableEngine.js';
import FileGenerator from './FileGenerator.js';
import DependencyManager from './DependencyManager.js';
import GitManager from './GitManager.js';
import PostProcessor from './PostProcessor.js';

export default class Generator {
  constructor(projectName, options = {}) {
    this.projectName = projectName;
    this.options = options;
    this.targetDir = resolve(projectName);
    
    // 初始化各个管理器
    this.templateManager = new TemplateManager();
    this.variableEngine = new VariableEngine();
    this.fileGenerator = new FileGenerator();
    this.dependencyManager = new DependencyManager();
    this.gitManager = new GitManager();
    this.postProcessor = new PostProcessor();
    
    this.progress = new ProgressManager();
  }

  /**
   * 生成项目
   */
  async generate() {
    const steps = [
      { name: '验证项目配置', method: 'validateProject' },
      { name: '获取模板', method: 'getTemplate' },
      { name: '处理模板变量', method: 'processTemplateVariables' },
      { name: '创建项目目录', method: 'createProjectDirectory' },
      { name: '生成项目文件', method: 'generateProjectFiles' },
      { name: '安装依赖', method: 'installDependencies' },
      { name: '初始化 Git', method: 'initializeGit' },
      { name: '执行后处理', method: 'runPostProcessing' }
    ];

    this.progress.setSteps(steps);

    try {
      await this.templateManager.initialize();
      
      for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        
        this.progress.updateStep(i, 'running');
        await this[step.method]();
        this.progress.updateStep(i, 'completed');
      }

      this.progress.succeed(`项目 ${this.projectName} 创建成功！`);
      await this.showCompletionSummary();

    } catch (error) {
      this.progress.fail(`项目创建失败: ${error.message}`);
      throw error;
    }
  }

  /**
   * 验证项目配置
   */
  async validateProject() {
    // 验证项目名称
    const nameValidation = validateProjectName(this.projectName);
    if (!nameValidation.valid) {
      throw new Error(`项目名称无效: ${nameValidation.errors.join(', ')}`);
    }

    // 检查目标目录
    if (existsSync(this.targetDir)) {
      if (!this.options.force) {
        throw new Error(`目录 ${this.projectName} 已存在`);
      }
      
      // 如果是强制模式，检查目录是否可写
      const stats = await stat(this.targetDir);
      if (!stats.isDirectory()) {
        throw new Error(`${this.projectName} 已存在且不是目录`);
      }
    }

    // 验证模板选项
    if (this.options.template && this.options.repo) {
      throw new Error('不能同时指定 template 和 repo 选项');
    }
  }

  /**
   * 获取模板
   */
  async getTemplate() {
    let templateId;

    if (this.options.template) {
      templateId = this.options.template;
    } else if (this.options.repo) {
      templateId = this.options.repo;
    } else if (this.options.localPath) {
      templateId = this.options.localPath;
    } else {
      // 使用默认模板
      templateId = 'vanilla-ts';
    }

    this.template = await this.templateManager.getTemplate(templateId, {
      force: this.options.force
    });

    logger.debug('模板获取成功:', templateId);
  }

  /**
   * 处理模板变量
   */
  async processTemplateVariables() {
    const variables = this.buildTemplateVariables();
    
    this.processedTemplate = this.variableEngine.processTemplate(
      this.template,
      variables
    );

    logger.debug('模板变量处理完成');
  }

  /**
   * 创建项目目录
   */
  async createProjectDirectory() {
    if (existsSync(this.targetDir) && this.options.force) {
      // 清空目录内容（保留目录本身）
      await this.clearDirectory(this.targetDir);
    } else {
      await mkdir(this.targetDir, { recursive: true });
    }

    logger.debug('项目目录创建完成:', this.targetDir);
  }

  /**
   * 生成项目文件
   */
  async generateProjectFiles() {
    await this.fileGenerator.generateFiles(
      this.processedTemplate,
      this.targetDir,
      {
        preserveMode: true,
        createDirectories: true,
        validateFiles: true
      }
    );

    logger.debug('项目文件生成完成');
  }

  /**
   * 安装依赖
   */
  async installDependencies() {
    if (this.options.skipInstall || !this.options.installDeps) {
      logger.debug('跳过依赖安装');
      return;
    }

    const packageManager = this.options.packageManager || 'npm';
    
    await this.dependencyManager.install(this.targetDir, {
      packageManager,
      verbose: this.options.verbose
    });

    logger.debug('依赖安装完成');
  }

  /**
   * 初始化 Git
   */
  async initializeGit() {
    if (this.options.skipGit || !this.options.initGit) {
      logger.debug('跳过 Git 初始化');
      return;
    }

    await this.gitManager.initialize(this.targetDir, {
      initialCommit: this.options.initialCommit,
      commitMessage: `feat: initial commit by TerraFE`
    });

    logger.debug('Git 初始化完成');
  }

  /**
   * 执行后处理
   */
  async runPostProcessing() {
    if (!this.template.config || !this.template.config.hooks) {
      return;
    }

    await this.postProcessor.run(
      this.template.config.hooks,
      this.targetDir,
      this.buildTemplateVariables()
    );

    logger.debug('后处理执行完成');
  }

  /**
   * 构建模板变量
   */
  buildTemplateVariables() {
    return {
      projectName: this.projectName,
      description: this.options.description || `A project created with TerraFE`,
      author: this.options.author || 'Anonymous',
      version: this.options.version || '1.0.0',
      license: this.options.license || 'MIT',
      packageManager: this.options.packageManager || 'npm',
      
      // 框架相关
      framework: this.options.framework || 'vanilla',
      typescript: this.options.typescript || false,
      cssPreprocessor: this.options.cssPreprocessor || 'none',
      
      // 工具相关
      tools: this.options.tools || [],
      
      // 时间相关
      currentYear: new Date().getFullYear(),
      currentDate: new Date().toISOString().split('T')[0],
      
      // 路径相关
      projectDir: this.targetDir,
      
      // 自定义变量
      ...this.options.variables
    };
  }

  /**
   * 清空目录
   */
  async clearDirectory(dir) {
    const items = await readdir(dir);
    
    for (const item of items) {
      const itemPath = join(dir, item);
      await rm(itemPath, { recursive: true, force: true });
    }
  }

  /**
   * 显示完成摘要
   */
  async showCompletionSummary() {
    console.log();
    logger.success('🎉 项目创建完成！');
    console.log();
    
    // 显示项目信息
    console.log(chalk.bold('项目信息:'));
    console.log(`  名称: ${chalk.cyan(this.projectName)}`);
    console.log(`  路径: ${chalk.gray(this.targetDir)}`);
    console.log(`  模板: ${chalk.gray(this.getTemplateDisplayName())}`);
    console.log();

    // 显示后续步骤
    console.log(chalk.bold('后续步骤:'));
    console.log(`  ${chalk.gray('cd')} ${this.projectName}`);
    
    if (!this.options.installDeps) {
      const pm = this.options.packageManager || 'npm';
      console.log(`  ${chalk.gray(pm)} install`);
    }
    
    console.log(`  ${chalk.gray('npm')} run dev`);
    console.log();

    // 显示有用的命令
    if (this.template.config && this.template.config.commands) {
      console.log(chalk.bold('可用命令:'));
      for (const [name, desc] of Object.entries(this.template.config.commands)) {
        console.log(`  ${chalk.gray(name)}: ${desc}`);
      }
      console.log();
    }

    // 显示文档链接
    if (this.template.config && this.template.config.documentation) {
      console.log(chalk.bold('相关文档:'));
      for (const [name, url] of Object.entries(this.template.config.documentation)) {
        console.log(`  ${name}: ${chalk.blue(url)}`);
      }
      console.log();
    }
  }

  /**
   * 获取模板显示名称
   */
  getTemplateDisplayName() {
    if (this.options.template) {
      return `官方模板: ${this.options.template}`;
    } else if (this.options.repo) {
      return `GitHub: ${this.options.repo}`;
    } else if (this.options.localPath) {
      return `本地: ${this.options.localPath}`;
    }
    return '默认模板';
  }
}
```

## 文件生成器实现

```javascript
// lib/core/FileGenerator.js
import { join, dirname } from 'path';
import { mkdir, writeFile, chmod } from 'fs/promises';

import logger from '../utils/logger.js';

export default class FileGenerator {
  /**
   * 生成所有文件
   */
  async generateFiles(template, targetDir, options = {}) {
    const {
      preserveMode = true,
      createDirectories = true,
      validateFiles = true
    } = options;

    for (const [filePath, fileInfo] of template.files) {
      await this.generateFile(
        filePath,
        fileInfo,
        targetDir,
        { preserveMode, createDirectories, validateFiles }
      );
    }
  }

  /**
   * 生成单个文件
   */
  async generateFile(filePath, fileInfo, targetDir, options) {
    const fullPath = join(targetDir, filePath);
    const dir = dirname(fullPath);

    // 创建目录
    if (options.createDirectories) {
      await mkdir(dir, { recursive: true });
    }

    // 写入文件内容
    if (fileInfo.content !== null) {
      await writeFile(fullPath, fileInfo.content);
      
      // 设置文件权限
      if (options.preserveMode && fileInfo.mode) {
        await chmod(fullPath, fileInfo.mode);
      }
    }

    // 验证文件
    if (options.validateFiles) {
      await this.validateGeneratedFile(fullPath, fileInfo);
    }

    logger.debug(`生成文件: ${filePath}`);
  }

  /**
   * 验证生成的文件
   */
  async validateGeneratedFile(filePath, expectedInfo) {
    try {
      const stats = await stat(filePath);
      
      // 验证文件大小（允许一定差异，因为变量替换可能改变大小）
      if (expectedInfo.size && Math.abs(stats.size - expectedInfo.size) > 1000) {
        logger.warn(`文件大小差异较大: ${filePath}`);
      }
      
      return true;
    } catch (error) {
      throw new Error(`文件验证失败 ${filePath}: ${error.message}`);
    }
  }

  /**
   * 批量创建目录结构
   */
  async createDirectoryStructure(structure, baseDir) {
    for (const dirPath of structure) {
      const fullPath = join(baseDir, dirPath);
      await mkdir(fullPath, { recursive: true });
    }
  }

  /**
   * 复制文件（用于二进制文件）
   */
  async copyBinaryFile(sourcePath, targetPath) {
    const targetDir = dirname(targetPath);
    await mkdir(targetDir, { recursive: true });
    
    await copyFile(sourcePath, targetPath);
    
    // 保持原文件权限
    const sourceStats = await stat(sourcePath);
    await chmod(targetPath, sourceStats.mode);
  }
}
```

## 依赖管理器实现

```javascript
// lib/core/DependencyManager.js
import { spawn } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';

import logger from '../utils/logger.js';
import { ProgressManager } from '../utils/progress.js';

export default class DependencyManager {
  constructor() {
    this.progress = new ProgressManager();
  }

  /**
   * 安装依赖
   */
  async install(projectDir, options = {}) {
    const { packageManager = 'npm', verbose = false } = options;

    // 检查 package.json 是否存在
    const packageJsonPath = join(projectDir, 'package.json');
    if (!existsSync(packageJsonPath)) {
      throw new Error('package.json 文件不存在');
    }

    // 检测包管理器是否可用
    await this.validatePackageManager(packageManager);

    this.progress.start(`使用 ${packageManager} 安装依赖...`);

    try {
      await this.runInstallCommand(packageManager, projectDir, verbose);
      this.progress.succeed('依赖安装完成');
    } catch (error) {
      this.progress.fail('依赖安装失败');
      throw error;
    }
  }

  /**
   * 验证包管理器
   */
  async validatePackageManager(packageManager) {
    try {
      await this.execCommand(packageManager, ['--version']);
    } catch (error) {
      throw new Error(`包管理器 ${packageManager} 不可用`);
    }
  }

  /**
   * 运行安装命令
   */
  async runInstallCommand(packageManager, projectDir, verbose) {
    const commands = {
      npm: ['install'],
      yarn: ['install'],
      pnpm: ['install']
    };

    const args = commands[packageManager];
    if (!args) {
      throw new Error(`不支持的包管理器: ${packageManager}`);
    }

    // 添加静默选项（非 verbose 模式）
    if (!verbose) {
      if (packageManager === 'npm') {
        args.push('--silent');
      } else if (packageManager === 'yarn') {
        args.push('--silent');
      } else if (packageManager === 'pnpm') {
        args.push('--reporter=silent');
      }
    }

    await this.execCommand(packageManager, args, {
      cwd: projectDir,
      stdio: verbose ? 'inherit' : 'ignore'
    });
  }

  /**
   * 添加依赖
   */
  async addDependency(projectDir, packages, options = {}) {
    const {
      packageManager = 'npm',
      dev = false,
      exact = false
    } = options;

    const commands = {
      npm: ['install'],
      yarn: ['add'],
      pnpm: ['add']
    };

    const args = [...commands[packageManager]];
    
    if (dev) {
      if (packageManager === 'npm') {
        args.push('--save-dev');
      } else {
        args.push('--dev');
      }
    }

    if (exact) {
      if (packageManager === 'npm') {
        args.push('--save-exact');
      } else if (packageManager === 'yarn') {
        args.push('--exact');
      }
    }

    args.push(...packages);

    await this.execCommand(packageManager, args, { cwd: projectDir });
  }

  /**
   * 执行命令
   */
  async execCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args, {
        stdio: 'pipe',
        ...options
      });

      let stdout = '';
      let stderr = '';

      if (child.stdout) {
        child.stdout.on('data', (data) => {
          stdout += data.toString();
        });
      }

      if (child.stderr) {
        child.stderr.on('data', (data) => {
          stderr += data.toString();
        });
      }

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          reject(new Error(`命令执行失败 (退出码: ${code}): ${stderr || stdout}`));
        }
      });

      child.on('error', (error) => {
        reject(new Error(`命令执行出错: ${error.message}`));
      });
    });
  }

  /**
   * 检测可用的包管理器
   */
  async detectAvailablePackageManagers() {
    const managers = ['pnpm', 'yarn', 'npm'];
    const available = [];

    for (const manager of managers) {
      try {
        const result = await this.execCommand(manager, ['--version']);
        available.push({
          name: manager,
          version: result.stdout.trim()
        });
      } catch {
        // 包管理器不可用
      }
    }

    return available;
  }

  /**
   * 获取推荐的包管理器
   */
  async getRecommendedPackageManager() {
    const available = await this.detectAvailablePackageManagers();
    
    // 按优先级排序
    const priority = ['pnpm', 'yarn', 'npm'];
    
    for (const pm of priority) {
      if (available.find(a => a.name === pm)) {
        return pm;
      }
    }
    
    return 'npm'; // 默认
  }
}
```

## Git 管理器实现

```javascript
// lib/core/GitManager.js
import { spawn } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';

import logger from '../utils/logger.js';

export default class GitManager {
  /**
   * 初始化 Git 仓库
   */
  async initialize(projectDir, options = {}) {
    const {
      initialCommit = true,
      commitMessage = 'Initial commit'
    } = options;

    // 检查是否已经是 Git 仓库
    const gitDir = join(projectDir, '.git');
    if (existsSync(gitDir)) {
      logger.warn('目录已是 Git 仓库，跳过初始化');
      return;
    }

    try {
      // 初始化仓库
      await this.execGitCommand(['init'], projectDir);
      logger.debug('Git 仓库初始化完成');

      // 添加所有文件
      await this.execGitCommand(['add', '.'], projectDir);
      logger.debug('文件添加到暂存区');

      // 创建初始提交
      if (initialCommit) {
        await this.execGitCommand(['commit', '-m', commitMessage], projectDir);
        logger.debug('初始提交创建完成');
      }

    } catch (error) {
      throw new Error(`Git 初始化失败: ${error.message}`);
    }
  }

  /**
   * 添加远程仓库
   */
  async addRemote(projectDir, name, url) {
    try {
      await this.execGitCommand(['remote', 'add', name, url], projectDir);
      logger.debug(`远程仓库 ${name} 添加完成`);
    } catch (error) {
      throw new Error(`添加远程仓库失败: ${error.message}`);
    }
  }

  /**
   * 创建分支
   */
  async createBranch(projectDir, branchName) {
    try {
      await this.execGitCommand(['checkout', '-b', branchName], projectDir);
      logger.debug(`分支 ${branchName} 创建完成`);
    } catch (error) {
      throw new Error(`创建分支失败: ${error.message}`);
    }
  }

  /**
   * 检查 Git 是否可用
   */
  async isGitAvailable() {
    try {
      await this.execGitCommand(['--version']);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 获取 Git 配置
   */
  async getGitConfig() {
    try {
      const nameResult = await this.execGitCommand(['config', 'user.name']);
      const emailResult = await this.execGitCommand(['config', 'user.email']);
      
      return {
        name: nameResult.stdout.trim(),
        email: emailResult.stdout.trim()
      };
    } catch {
      return { name: '', email: '' };
    }
  }

  /**
   * 执行 Git 命令
   */
  async execGitCommand(args, cwd = process.cwd()) {
    return new Promise((resolve, reject) => {
      const child = spawn('git', args, {
        cwd,
        stdio: 'pipe'
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          reject(new Error(`Git 命令失败: ${stderr || stdout}`));
        }
      });

      child.on('error', (error) => {
        reject(new Error(`Git 命令执行出错: ${error.message}`));
      });
    });
  }
}
```

## 总结

本文详细介绍了 TerraFE 项目生成系统的完整实现：

1. **项目生成器**：协调整个生成流程的核心组件
2. **文件生成器**：处理文件系统操作和权限管理
3. **依赖管理器**：智能的包管理器检测和依赖安装
4. **Git 管理器**：完整的 Git 仓库初始化功能

这套系统确保了项目生成过程的可靠性和用户体验。

## 下期预告

**《TerraFE 脚手架开发实战系列（六）：错误处理与用户体验优化》**

- 全局错误处理策略
- 用户友好的错误提示
- 操作恢复机制
- 性能优化技巧

---

*如果这篇文章对你有帮助，欢迎点赞和转发。有任何问题或建议，欢迎在评论区讨论！* 