# TerraFE 脚手架开发实战系列（七）：测试与发布

## 前言

测试和发布是软件开发生命周期的关键环节。本文将详细介绍 TerraFE 的测试策略、CI/CD 流水线配置以及 NPM 包发布流程，确保工具的质量和可靠性。

## 测试策略设计

### 测试金字塔

```
    E2E Tests (少量)
         △
        /|\
       / | \
      /  |  \
     /   |   \
    /    |    \
   /_____▼_____\
  Integration Tests (中等)
  /_________________\
    Unit Tests (大量)
```

### 测试类型分层

1. **单元测试 (70%)**：测试独立的函数和类
2. **集成测试 (20%)**：测试模块间的交互
3. **端到端测试 (10%)**：测试完整的用户流程

## 单元测试实现

### Jest 配置

```javascript
// jest.config.js
export default {
  // 测试环境
  testEnvironment: 'node',
  
  // ES 模块支持
  extensionsToTreatAsEsm: ['.js'],
  globals: {
    'ts-jest': {
      useESM: true
    }
  },
  
  // 测试文件匹配
  testMatch: [
    '**/__tests__/**/*.test.js',
    '**/?(*.)+(spec|test).js'
  ],
  
  // 覆盖率配置
  collectCoverageFrom: [
    'lib/**/*.js',
    'bin/**/*.js',
    '!**/node_modules/**',
    '!**/coverage/**',
    '!**/*.config.js'
  ],
  
  // 覆盖率阈值
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  
  // 模块映射
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/lib/$1'
  },
  
  // 设置文件
  setupFilesAfterEnv: ['<rootDir>/__tests__/setup.js'],
  
  // 忽略模式
  testPathIgnorePatterns: [
    '/node_modules/',
    '/coverage/',
    '/dist/'
  ]
};
```

### 测试工具类

```javascript
// __tests__/utils/testUtils.js
import { jest } from '@jest/globals';
import { tmpdir } from 'os';
import { join } from 'path';
import { mkdir, writeFile, rm } from 'fs/promises';
import { randomBytes } from 'crypto';

export class TestUtils {
  /**
   * 创建临时目录
   */
  static async createTempDir(prefix = 'terrafe-test') {
    const tempName = `${prefix}-${randomBytes(8).toString('hex')}`;
    const tempPath = join(tmpdir(), tempName);
    await mkdir(tempPath, { recursive: true });
    return tempPath;
  }

  /**
   * 清理临时目录
   */
  static async cleanupTempDir(tempPath) {
    try {
      await rm(tempPath, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  }

  /**
   * 创建模拟文件
   */
  static async createMockFiles(basePath, files) {
    for (const [filePath, content] of Object.entries(files)) {
      const fullPath = join(basePath, filePath);
      const dir = dirname(fullPath);
      await mkdir(dir, { recursive: true });
      await writeFile(fullPath, content);
    }
  }

  /**
   * 模拟命令行参数
   */
  static mockCliArgs(args) {
    const originalArgv = process.argv;
    process.argv = ['node', 'terrafe', ...args];
    
    return () => {
      process.argv = originalArgv;
    };
  }

  /**
   * 模拟环境变量
   */
  static mockEnvVars(vars) {
    const originalEnv = { ...process.env };
    Object.assign(process.env, vars);
    
    return () => {
      process.env = originalEnv;
    };
  }

  /**
   * 模拟网络请求
   */
  static mockFetch(responses) {
    const mockFetch = jest.fn();
    
    responses.forEach(({ url, response }) => {
      mockFetch
        .mockImplementationOnce(() => Promise.resolve({
          ok: response.ok !== false,
          status: response.status || 200,
          json: () => Promise.resolve(response.data || {}),
          text: () => Promise.resolve(response.text || '')
        }));
    });

    global.fetch = mockFetch;
    return mockFetch;
  }

  /**
   * 模拟 Git 命令
   */
  static mockGitCommands() {
    const mockExec = jest.fn();
    
    // 模拟常见 Git 命令
    mockExec
      .mockImplementation((command) => {
        if (command.includes('git --version')) {
          return Promise.resolve({ stdout: 'git version 2.30.0' });
        }
        if (command.includes('git config user.name')) {
          return Promise.resolve({ stdout: 'Test User' });
        }
        if (command.includes('git config user.email')) {
          return Promise.resolve({ stdout: 'test@example.com' });
        }
        return Promise.resolve({ stdout: '', stderr: '' });
      });

    return mockExec;
  }

  /**
   * 断言文件存在
   */
  static async assertFileExists(filePath, message) {
    const exists = await existsSync(filePath);
    expect(exists).toBe(true);
  }

  /**
   * 断言文件内容
   */
  static async assertFileContent(filePath, expectedContent) {
    const content = await readFile(filePath, 'utf8');
    expect(content).toContain(expectedContent);
  }

  /**
   * 等待异步操作
   */
  static async waitFor(condition, timeout = 5000, interval = 100) {
    const start = Date.now();
    
    while (Date.now() - start < timeout) {
      if (await condition()) {
        return;
      }
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('Timeout waiting for condition');
  }
}
```

### 核心模块测试示例

```javascript
// __tests__/core/Generator.test.js
import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { join } from 'path';
import { existsSync } from 'fs';

import Generator from '../../lib/core/Generator.js';
import { TestUtils } from '../utils/testUtils.js';

describe('Generator', () => {
  let tempDir;
  let generator;
  let mockTemplateManager;

  beforeEach(async () => {
    tempDir = await TestUtils.createTempDir('generator-test');
    
    // 模拟模板管理器
    mockTemplateManager = {
      initialize: jest.fn(),
      getTemplate: jest.fn()
    };

    generator = new Generator('test-project', {
      targetDir: join(tempDir, 'test-project')
    });
    
    generator.templateManager = mockTemplateManager;
  });

  afterEach(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  describe('项目名称验证', () => {
    test('应该接受有效的项目名称', async () => {
      const result = await generator.validateProjectName('my-awesome-project');
      expect(result.valid).toBe(true);
    });

    test('应该拒绝无效的项目名称', async () => {
      const result = await generator.validateProjectName('My Project!');
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('项目名称只能包含小写字母、数字、连字符和下划线');
    });

    test('应该拒绝空项目名称', async () => {
      const result = await generator.validateProjectName('');
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('项目名称不能为空');
    });
  });

  describe('模板处理', () => {
    test('应该成功获取模板', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "{{projectName}}"}' }],
          ['src/index.js', { content: 'console.log("Hello {{projectName}}");' }]
        ]),
        config: null
      };

      mockTemplateManager.getTemplate.mockResolvedValue(mockTemplate);

      await generator.getTemplate();
      
      expect(mockTemplateManager.getTemplate).toHaveBeenCalledWith(
        'vanilla-ts',
        { force: undefined }
      );
      expect(generator.template).toBe(mockTemplate);
    });

    test('应该处理模板变量替换', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "{{projectName}}"}' }]
        ])
      };

      generator.template = mockTemplate;
      await generator.processTemplateVariables();

      const processedFiles = generator.processedTemplate.files;
      const packageJsonContent = processedFiles.get('package.json').content;
      
      expect(packageJsonContent).toContain('"name": "test-project"');
    });
  });

  describe('文件生成', () => {
    test('应该创建项目目录', async () => {
      await generator.createProjectDirectory();
      
      expect(existsSync(generator.targetDir)).toBe(true);
    });

    test('应该生成项目文件', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "test-project"}' }],
          ['README.md', { content: '# test-project' }]
        ])
      };

      generator.processedTemplate = mockTemplate;
      await generator.createProjectDirectory();
      await generator.generateProjectFiles();

      expect(existsSync(join(generator.targetDir, 'package.json'))).toBe(true);
      expect(existsSync(join(generator.targetDir, 'README.md'))).toBe(true);
    });
  });

  describe('完整生成流程', () => {
    test('应该成功生成完整项目', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { 
            content: JSON.stringify({
              name: '{{projectName}}',
              version: '{{version}}',
              description: '{{description}}'
            }, null, 2)
          }],
          ['src/index.ts', { content: 'console.log("Hello {{projectName}}");' }],
          ['.gitignore', { content: 'node_modules/\ndist/' }]
        ]),
        config: null
      };

      mockTemplateManager.getTemplate.mockResolvedValue(mockTemplate);

      // 跳过依赖安装和 Git 初始化以简化测试
      generator.options.skipInstall = true;
      generator.options.skipGit = true;

      await generator.generate();

      // 验证文件是否创建
      await TestUtils.assertFileExists(join(generator.targetDir, 'package.json'));
      await TestUtils.assertFileExists(join(generator.targetDir, 'src/index.ts'));
      await TestUtils.assertFileExists(join(generator.targetDir, '.gitignore'));

      // 验证变量替换
      await TestUtils.assertFileContent(
        join(generator.targetDir, 'package.json'),
        '"name": "test-project"'
      );
    });
  });
});
```

### 命令测试

```javascript
// __tests__/commands/create.test.js
import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { createProject, validateCreateOptions } from '../../lib/commands/create.js';
import { TestUtils } from '../utils/testUtils.js';

describe('create 命令', () => {
  let tempDir;
  let restoreArgs;

  beforeEach(async () => {
    tempDir = await TestUtils.createTempDir('create-test');
    process.chdir(tempDir);
  });

  afterEach(async () => {
    if (restoreArgs) restoreArgs();
    await TestUtils.cleanupTempDir(tempDir);
  });

  describe('参数验证', () => {
    test('应该验证有效的项目名称', () => {
      const result = validateCreateOptions('my-project', {});
      expect(result).toBe(true);
    });

    test('应该拒绝无效的项目名称', () => {
      const result = validateCreateOptions('My Project', {});
      expect(result).toBe(false);
    });

    test('应该检查目录冲突', () => {
      // 创建已存在的目录
      const existingDir = join(tempDir, 'existing-project');
      mkdirSync(existingDir);

      const result = validateCreateOptions('existing-project', {});
      expect(result).toBe(false);
    });

    test('应该允许强制覆盖', () => {
      const existingDir = join(tempDir, 'existing-project');
      mkdirSync(existingDir);

      const result = validateCreateOptions('existing-project', { force: true });
      expect(result).toBe(true);
    });
  });

  describe('项目创建', () => {
    test('应该创建基础项目', async () => {
      const projectName = 'test-project';
      const options = {
        skipInstall: true,
        skipGit: true,
        yes: true
      };

      await createProject(projectName, options);

      expect(existsSync(join(tempDir, projectName))).toBe(true);
      expect(existsSync(join(tempDir, projectName, 'package.json'))).toBe(true);
    });

    test('应该处理模板选项', async () => {
      const projectName = 'react-project';
      const options = {
        template: 'react-ts',
        skipInstall: true,
        skipGit: true,
        yes: true
      };

      await createProject(projectName, options);

      const packageJsonPath = join(tempDir, projectName, 'package.json');
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
      
      expect(packageJson.dependencies).toHaveProperty('react');
      expect(packageJson.devDependencies).toHaveProperty('typescript');
    });
  });
});
```

## 集成测试

### API 集成测试

```javascript
// __tests__/integration/api.test.js
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { spawn } from 'child_process';
import { TestUtils } from '../utils/testUtils.js';

describe('API 集成测试', () => {
  let tempDir;

  beforeAll(async () => {
    tempDir = await TestUtils.createTempDir('integration-test');
  });

  afterAll(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  test('命令行接口应该正常工作', async () => {
    const result = await runCliCommand(['--version']);
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toMatch(/\d+\.\d+\.\d+/);
  });

  test('创建命令应该生成完整项目', async () => {
    const projectName = 'integration-test-project';
    const result = await runCliCommand([
      'create', projectName,
      '--yes',
      '--skip-install',
      '--skip-git'
    ], { cwd: tempDir });

    expect(result.exitCode).toBe(0);
    
    // 验证项目文件
    const projectPath = join(tempDir, projectName);
    expect(existsSync(join(projectPath, 'package.json'))).toBe(true);
    expect(existsSync(join(projectPath, 'src'))).toBe(true);
  });

  test('模板命令应该列出可用模板', async () => {
    const result = await runCliCommand(['template', 'list']);
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('react-ts');
    expect(result.stdout).toContain('vue-ts');
  });

  test('配置命令应该管理用户配置', async () => {
    // 设置配置
    let result = await runCliCommand(['config', 'set', 'packageManager', 'pnpm']);
    expect(result.exitCode).toBe(0);

    // 获取配置
    result = await runCliCommand(['config', 'get', 'packageManager']);
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('pnpm');

    // 删除配置
    result = await runCliCommand(['config', 'delete', 'packageManager']);
    expect(result.exitCode).toBe(0);
  });

  async function runCliCommand(args, options = {}) {
    return new Promise((resolve) => {
      const child = spawn('node', ['../../bin/index.js', ...args], {
        stdio: 'pipe',
        ...options
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (exitCode) => {
        resolve({ exitCode, stdout, stderr });
      });
    });
  }
});
```

## 端到端测试

### E2E 测试框架

```javascript
// __tests__/e2e/userFlow.test.js
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { TestUtils } from '../utils/testUtils.js';

describe('用户完整流程测试', () => {
  let tempDir;

  beforeAll(async () => {
    tempDir = await TestUtils.createTempDir('e2e-test');
  });

  afterAll(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  test('新用户创建 React 项目的完整流程', async () => {
    const projectName = 'my-react-app';
    
    // 步骤 1: 创建项目
    const createResult = await TestUtils.runCommand([
      'create', projectName,
      '--template', 'react-ts',
      '--yes',
      '--skip-install' // 跳过安装以加快测试
    ], { cwd: tempDir });

    expect(createResult.exitCode).toBe(0);
    expect(createResult.stdout).toContain('项目创建成功');

    // 步骤 2: 验证项目结构
    const projectPath = join(tempDir, projectName);
    const expectedFiles = [
      'package.json',
      'tsconfig.json',
      'src/App.tsx',
      'src/main.tsx',
      'index.html',
      'vite.config.ts'
    ];

    for (const file of expectedFiles) {
      expect(existsSync(join(projectPath, file))).toBe(true);
    }

    // 步骤 3: 验证 package.json 内容
    const packageJson = JSON.parse(
      readFileSync(join(projectPath, 'package.json'), 'utf8')
    );
    
    expect(packageJson.name).toBe(projectName);
    expect(packageJson.dependencies).toHaveProperty('react');
    expect(packageJson.devDependencies).toHaveProperty('typescript');
    expect(packageJson.devDependencies).toHaveProperty('vite');

    // 步骤 4: 验证 TypeScript 配置
    const tsConfig = JSON.parse(
      readFileSync(join(projectPath, 'tsconfig.json'), 'utf8')
    );
    
    expect(tsConfig.compilerOptions.target).toBe('ES2020');
    expect(tsConfig.compilerOptions.jsx).toBe('react-jsx');
  });

  test('用户自定义项目配置流程', async () => {
    const projectName = 'custom-project';
    
    // 使用交互式创建（模拟用户输入）
    const createResult = await TestUtils.runCommandWithInput([
      'create', projectName
    ], [
      'vue',           // 选择 Vue 框架
      'true',          // 使用 TypeScript
      'pnpm',          // 选择 pnpm
      'true',          // 初始化 Git
      'false'          // 不立即安装依赖
    ], { cwd: tempDir });

    expect(createResult.exitCode).toBe(0);

    // 验证生成的项目
    const projectPath = join(tempDir, projectName);
    const packageJson = JSON.parse(
      readFileSync(join(projectPath, 'package.json'), 'utf8')
    );

    expect(packageJson.dependencies).toHaveProperty('vue');
    expect(packageJson.devDependencies).toHaveProperty('typescript');
  });

  test('错误处理和恢复流程', async () => {
    // 测试无效项目名称
    const invalidResult = await TestUtils.runCommand([
      'create', 'Invalid Project Name!'
    ], { cwd: tempDir });

    expect(invalidResult.exitCode).toBe(1);
    expect(invalidResult.stderr).toContain('项目名称不合法');

    // 测试目录冲突
    const existingDir = join(tempDir, 'existing-project');
    mkdirSync(existingDir);

    const conflictResult = await TestUtils.runCommand([
      'create', 'existing-project'
    ], { cwd: tempDir });

    expect(conflictResult.exitCode).toBe(1);
    expect(conflictResult.stderr).toContain('目录已存在');

    // 测试强制覆盖
    const forceResult = await TestUtils.runCommand([
      'create', 'existing-project',
      '--force',
      '--yes',
      '--skip-install',
      '--skip-git'
    ], { cwd: tempDir });

    expect(forceResult.exitCode).toBe(0);
  });
});
```

## CI/CD 流水线配置

### GitHub Actions 配置

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '18'

jobs:
  test:
    name: Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16, 18, 20]

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Run security audit
        run: npm audit --audit-level=high

      - name: Run dependency scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, security]
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build package
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: dist/

  publish:
    name: Publish to NPM
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: github.event_name == 'release'
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci

      - name: Build package
        run: npm run build

      - name: Publish to NPM
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub release notes
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
```

### 发布前检查脚本

```javascript
// scripts/pre-publish.js
import { readFile, writeFile } from 'fs/promises';
import { execSync } from 'child_process';
import chalk from 'chalk';

async function prePublishChecks() {
  console.log(chalk.blue('🔍 执行发布前检查...'));

  try {
    // 检查 1: 验证 package.json
    await validatePackageJson();
    
    // 检查 2: 运行所有测试
    await runTests();
    
    // 检查 3: 检查代码质量
    await checkCodeQuality();
    
    // 检查 4: 验证构建
    await validateBuild();
    
    // 检查 5: 检查版本号
    await checkVersion();
    
    // 检查 6: 生成变更日志
    await generateChangelog();

    console.log(chalk.green('✅ 所有检查通过，可以发布！'));
    
  } catch (error) {
    console.error(chalk.red('❌ 发布前检查失败:'), error.message);
    process.exit(1);
  }
}

async function validatePackageJson() {
  console.log(chalk.gray('📦 验证 package.json...'));
  
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  
  // 必需字段检查
  const requiredFields = ['name', 'version', 'description', 'main', 'bin'];
  for (const field of requiredFields) {
    if (!packageJson[field]) {
      throw new Error(`package.json 缺少必需字段: ${field}`);
    }
  }
  
  // 关键词检查
  if (!packageJson.keywords || packageJson.keywords.length === 0) {
    throw new Error('package.json 缺少关键词');
  }
  
  // 仓库信息检查
  if (!packageJson.repository) {
    throw new Error('package.json 缺少仓库信息');
  }
}

async function runTests() {
  console.log(chalk.gray('🧪 运行测试套件...'));
  
  try {
    execSync('npm run test:all', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('测试失败');
  }
}

async function checkCodeQuality() {
  console.log(chalk.gray('🔍 检查代码质量...'));
  
  try {
    execSync('npm run lint', { stdio: 'inherit' });
    execSync('npm run type-check', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('代码质量检查失败');
  }
}

async function validateBuild() {
  console.log(chalk.gray('🏗️ 验证构建...'));
  
  try {
    execSync('npm run build', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('构建失败');
  }
}

async function checkVersion() {
  console.log(chalk.gray('📋 检查版本号...'));
  
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  const currentVersion = packageJson.version;
  
  // 检查是否为有效的语义化版本
  const semverRegex = /^\d+\.\d+\.\d+(-[a-zA-Z0-9-]+)?$/;
  if (!semverRegex.test(currentVersion)) {
    throw new Error(`无效的版本号: ${currentVersion}`);
  }
  
  // 检查版本是否已发布
  try {
    const publishedVersions = execSync(
      `npm view ${packageJson.name} versions --json`,
      { encoding: 'utf8' }
    );
    
    const versions = JSON.parse(publishedVersions);
    if (versions.includes(currentVersion)) {
      throw new Error(`版本 ${currentVersion} 已经发布`);
    }
  } catch (error) {
    // 如果包还没有发布，这是正常的
    if (!error.message.includes('404')) {
      throw error;
    }
  }
}

async function generateChangelog() {
  console.log(chalk.gray('📝 生成变更日志...'));
  
  try {
    execSync('npx conventional-changelog -p angular -i CHANGELOG.md -s', {
      stdio: 'inherit'
    });
  } catch (error) {
    console.warn(chalk.yellow('⚠️ 变更日志生成失败，请手动更新'));
  }
}

prePublishChecks();
```

## NPM 包发布

### 发布配置

```json
{
  "scripts": {
    "prepublishOnly": "node scripts/pre-publish.js",
    "postpublish": "node scripts/post-publish.js"
  },
  "files": [
    "bin/",
    "lib/",
    "README.md",
    "LICENSE"
  ],
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  }
}
```

### 版本管理脚本

```javascript
// scripts/release.js
import inquirer from 'inquirer';
import { execSync } from 'child_process';
import chalk from 'chalk';

async function release() {
  console.log(chalk.blue('🚀 开始发布流程...'));

  try {
    // 1. 选择版本类型
    const { versionType } = await inquirer.prompt([
      {
        type: 'list',
        name: 'versionType',
        message: '选择版本类型:',
        choices: [
          { name: 'patch (bug 修复)', value: 'patch' },
          { name: 'minor (新功能)', value: 'minor' },
          { name: 'major (破坏性变更)', value: 'major' },
          { name: 'prerelease (预发布)', value: 'prerelease' },
          { name: 'custom (自定义)', value: 'custom' }
        ]
      }
    ]);

    let newVersion;
    if (versionType === 'custom') {
      const { customVersion } = await inquirer.prompt([
        {
          type: 'input',
          name: 'customVersion',
          message: '输入版本号:',
          validate: (input) => {
            const semverRegex = /^\d+\.\d+\.\d+(-[a-zA-Z0-9-]+)?$/;
            return semverRegex.test(input) || '请输入有效的语义化版本号';
          }
        }
      ]);
      newVersion = customVersion;
    } else {
      // 使用 npm version 自动递增
      newVersion = execSync(`npm version ${versionType} --no-git-tag-version`, {
        encoding: 'utf8'
      }).trim();
    }

    console.log(chalk.green(`新版本: ${newVersion}`));

    // 2. 确认发布
    const { confirmPublish } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirmPublish',
        message: `确认发布版本 ${newVersion}?`,
        default: false
      }
    ]);

    if (!confirmPublish) {
      console.log(chalk.yellow('发布已取消'));
      return;
    }

    // 3. 提交版本变更
    execSync(`git add package.json package-lock.json`);
    execSync(`git commit -m "chore: release ${newVersion}"`);
    execSync(`git tag ${newVersion}`);

    // 4. 推送到远程仓库
    execSync('git push origin main --follow-tags');

    // 5. 发布到 NPM
    execSync('npm publish');

    console.log(chalk.green(`🎉 版本 ${newVersion} 发布成功！`));

  } catch (error) {
    console.error(chalk.red('发布失败:'), error.message);
    process.exit(1);
  }
}

release();
```

## 总结

本文详细介绍了 TerraFE 的完整测试和发布流程：

1. **测试策略**：单元测试、集成测试、端到端测试的完整覆盖
2. **CI/CD 流水线**：自动化的测试、构建和发布流程
3. **质量保证**：代码质量检查、安全扫描、覆盖率监控
4. **发布管理**：版本控制、变更日志、发布检查

这套完整的质量保证体系确保了 TerraFE 的稳定性和可靠性，为用户提供高质量的开发工具。

## 系列总结

通过这七篇文章，我们完整地介绍了 TerraFE 脚手架工具的开发全过程：

1. **架构设计与技术选型**：奠定了项目的技术基础
2. **CLI 工具基础搭建**：建立了命令行框架
3. **命令行交互与参数处理**：实现了用户友好的交互
4. **模板系统设计与实现**：构建了灵活的模板管理
5. **文件操作与项目生成**：完成了核心功能实现
6. **错误处理与用户体验优化**：提升了工具的可用性
7. **测试与发布**：保证了产品质量

希望这个系列能够为想要开发 CLI 工具的开发者提供完整的参考和指导！

---

*感谢您跟随这个系列到最后！如果对您有帮助，欢迎点赞、转发和关注。* 