# TerraFE è„šæ‰‹æ¶å¼€å‘å®æˆ˜ç³»åˆ—ï¼ˆä¸ƒï¼‰ï¼šæµ‹è¯•ä¸å‘å¸ƒ

## å‰è¨€

æµ‹è¯•å’Œå‘å¸ƒæ˜¯è½¯ä»¶å¼€å‘ç”Ÿå‘½å‘¨æœŸçš„å…³é”®ç¯èŠ‚ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç» TerraFE çš„æµ‹è¯•ç­–ç•¥ã€CI/CD æµæ°´çº¿é…ç½®ä»¥åŠ NPM åŒ…å‘å¸ƒæµç¨‹ï¼Œç¡®ä¿å·¥å…·çš„è´¨é‡å’Œå¯é æ€§ã€‚

## æµ‹è¯•ç­–ç•¥è®¾è®¡

### æµ‹è¯•é‡‘å­—å¡”

```
    E2E Tests (å°‘é‡)
         â–³
        /|\
       / | \
      /  |  \
     /   |   \
    /    |    \
   /_____â–¼_____\
  Integration Tests (ä¸­ç­‰)
  /_________________\
    Unit Tests (å¤§é‡)
```

### æµ‹è¯•ç±»å‹åˆ†å±‚

1. **å•å…ƒæµ‹è¯• (70%)**ï¼šæµ‹è¯•ç‹¬ç«‹çš„å‡½æ•°å’Œç±»
2. **é›†æˆæµ‹è¯• (20%)**ï¼šæµ‹è¯•æ¨¡å—é—´çš„äº¤äº’
3. **ç«¯åˆ°ç«¯æµ‹è¯• (10%)**ï¼šæµ‹è¯•å®Œæ•´çš„ç”¨æˆ·æµç¨‹

## å•å…ƒæµ‹è¯•å®ç°

### Jest é…ç½®

```javascript
// jest.config.js
export default {
  // æµ‹è¯•ç¯å¢ƒ
  testEnvironment: 'node',
  
  // ES æ¨¡å—æ”¯æŒ
  extensionsToTreatAsEsm: ['.js'],
  globals: {
    'ts-jest': {
      useESM: true
    }
  },
  
  // æµ‹è¯•æ–‡ä»¶åŒ¹é…
  testMatch: [
    '**/__tests__/**/*.test.js',
    '**/?(*.)+(spec|test).js'
  ],
  
  // è¦†ç›–ç‡é…ç½®
  collectCoverageFrom: [
    'lib/**/*.js',
    'bin/**/*.js',
    '!**/node_modules/**',
    '!**/coverage/**',
    '!**/*.config.js'
  ],
  
  // è¦†ç›–ç‡é˜ˆå€¼
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  
  // æ¨¡å—æ˜ å°„
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/lib/$1'
  },
  
  // è®¾ç½®æ–‡ä»¶
  setupFilesAfterEnv: ['<rootDir>/__tests__/setup.js'],
  
  // å¿½ç•¥æ¨¡å¼
  testPathIgnorePatterns: [
    '/node_modules/',
    '/coverage/',
    '/dist/'
  ]
};
```

### æµ‹è¯•å·¥å…·ç±»

```javascript
// __tests__/utils/testUtils.js
import { jest } from '@jest/globals';
import { tmpdir } from 'os';
import { join } from 'path';
import { mkdir, writeFile, rm } from 'fs/promises';
import { randomBytes } from 'crypto';

export class TestUtils {
  /**
   * åˆ›å»ºä¸´æ—¶ç›®å½•
   */
  static async createTempDir(prefix = 'terrafe-test') {
    const tempName = `${prefix}-${randomBytes(8).toString('hex')}`;
    const tempPath = join(tmpdir(), tempName);
    await mkdir(tempPath, { recursive: true });
    return tempPath;
  }

  /**
   * æ¸…ç†ä¸´æ—¶ç›®å½•
   */
  static async cleanupTempDir(tempPath) {
    try {
      await rm(tempPath, { recursive: true, force: true });
    } catch (error) {
      // å¿½ç•¥æ¸…ç†é”™è¯¯
    }
  }

  /**
   * åˆ›å»ºæ¨¡æ‹Ÿæ–‡ä»¶
   */
  static async createMockFiles(basePath, files) {
    for (const [filePath, content] of Object.entries(files)) {
      const fullPath = join(basePath, filePath);
      const dir = dirname(fullPath);
      await mkdir(dir, { recursive: true });
      await writeFile(fullPath, content);
    }
  }

  /**
   * æ¨¡æ‹Ÿå‘½ä»¤è¡Œå‚æ•°
   */
  static mockCliArgs(args) {
    const originalArgv = process.argv;
    process.argv = ['node', 'terrafe', ...args];
    
    return () => {
      process.argv = originalArgv;
    };
  }

  /**
   * æ¨¡æ‹Ÿç¯å¢ƒå˜é‡
   */
  static mockEnvVars(vars) {
    const originalEnv = { ...process.env };
    Object.assign(process.env, vars);
    
    return () => {
      process.env = originalEnv;
    };
  }

  /**
   * æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
   */
  static mockFetch(responses) {
    const mockFetch = jest.fn();
    
    responses.forEach(({ url, response }) => {
      mockFetch
        .mockImplementationOnce(() => Promise.resolve({
          ok: response.ok !== false,
          status: response.status || 200,
          json: () => Promise.resolve(response.data || {}),
          text: () => Promise.resolve(response.text || '')
        }));
    });

    global.fetch = mockFetch;
    return mockFetch;
  }

  /**
   * æ¨¡æ‹Ÿ Git å‘½ä»¤
   */
  static mockGitCommands() {
    const mockExec = jest.fn();
    
    // æ¨¡æ‹Ÿå¸¸è§ Git å‘½ä»¤
    mockExec
      .mockImplementation((command) => {
        if (command.includes('git --version')) {
          return Promise.resolve({ stdout: 'git version 2.30.0' });
        }
        if (command.includes('git config user.name')) {
          return Promise.resolve({ stdout: 'Test User' });
        }
        if (command.includes('git config user.email')) {
          return Promise.resolve({ stdout: 'test@example.com' });
        }
        return Promise.resolve({ stdout: '', stderr: '' });
      });

    return mockExec;
  }

  /**
   * æ–­è¨€æ–‡ä»¶å­˜åœ¨
   */
  static async assertFileExists(filePath, message) {
    const exists = await existsSync(filePath);
    expect(exists).toBe(true);
  }

  /**
   * æ–­è¨€æ–‡ä»¶å†…å®¹
   */
  static async assertFileContent(filePath, expectedContent) {
    const content = await readFile(filePath, 'utf8');
    expect(content).toContain(expectedContent);
  }

  /**
   * ç­‰å¾…å¼‚æ­¥æ“ä½œ
   */
  static async waitFor(condition, timeout = 5000, interval = 100) {
    const start = Date.now();
    
    while (Date.now() - start < timeout) {
      if (await condition()) {
        return;
      }
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('Timeout waiting for condition');
  }
}
```

### æ ¸å¿ƒæ¨¡å—æµ‹è¯•ç¤ºä¾‹

```javascript
// __tests__/core/Generator.test.js
import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { join } from 'path';
import { existsSync } from 'fs';

import Generator from '../../lib/core/Generator.js';
import { TestUtils } from '../utils/testUtils.js';

describe('Generator', () => {
  let tempDir;
  let generator;
  let mockTemplateManager;

  beforeEach(async () => {
    tempDir = await TestUtils.createTempDir('generator-test');
    
    // æ¨¡æ‹Ÿæ¨¡æ¿ç®¡ç†å™¨
    mockTemplateManager = {
      initialize: jest.fn(),
      getTemplate: jest.fn()
    };

    generator = new Generator('test-project', {
      targetDir: join(tempDir, 'test-project')
    });
    
    generator.templateManager = mockTemplateManager;
  });

  afterEach(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  describe('é¡¹ç›®åç§°éªŒè¯', () => {
    test('åº”è¯¥æ¥å—æœ‰æ•ˆçš„é¡¹ç›®åç§°', async () => {
      const result = await generator.validateProjectName('my-awesome-project');
      expect(result.valid).toBe(true);
    });

    test('åº”è¯¥æ‹’ç»æ— æ•ˆçš„é¡¹ç›®åç§°', async () => {
      const result = await generator.validateProjectName('My Project!');
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('é¡¹ç›®åç§°åªèƒ½åŒ…å«å°å†™å­—æ¯ã€æ•°å­—ã€è¿å­—ç¬¦å’Œä¸‹åˆ’çº¿');
    });

    test('åº”è¯¥æ‹’ç»ç©ºé¡¹ç›®åç§°', async () => {
      const result = await generator.validateProjectName('');
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('é¡¹ç›®åç§°ä¸èƒ½ä¸ºç©º');
    });
  });

  describe('æ¨¡æ¿å¤„ç†', () => {
    test('åº”è¯¥æˆåŠŸè·å–æ¨¡æ¿', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "{{projectName}}"}' }],
          ['src/index.js', { content: 'console.log("Hello {{projectName}}");' }]
        ]),
        config: null
      };

      mockTemplateManager.getTemplate.mockResolvedValue(mockTemplate);

      await generator.getTemplate();
      
      expect(mockTemplateManager.getTemplate).toHaveBeenCalledWith(
        'vanilla-ts',
        { force: undefined }
      );
      expect(generator.template).toBe(mockTemplate);
    });

    test('åº”è¯¥å¤„ç†æ¨¡æ¿å˜é‡æ›¿æ¢', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "{{projectName}}"}' }]
        ])
      };

      generator.template = mockTemplate;
      await generator.processTemplateVariables();

      const processedFiles = generator.processedTemplate.files;
      const packageJsonContent = processedFiles.get('package.json').content;
      
      expect(packageJsonContent).toContain('"name": "test-project"');
    });
  });

  describe('æ–‡ä»¶ç”Ÿæˆ', () => {
    test('åº”è¯¥åˆ›å»ºé¡¹ç›®ç›®å½•', async () => {
      await generator.createProjectDirectory();
      
      expect(existsSync(generator.targetDir)).toBe(true);
    });

    test('åº”è¯¥ç”Ÿæˆé¡¹ç›®æ–‡ä»¶', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { content: '{"name": "test-project"}' }],
          ['README.md', { content: '# test-project' }]
        ])
      };

      generator.processedTemplate = mockTemplate;
      await generator.createProjectDirectory();
      await generator.generateProjectFiles();

      expect(existsSync(join(generator.targetDir, 'package.json'))).toBe(true);
      expect(existsSync(join(generator.targetDir, 'README.md'))).toBe(true);
    });
  });

  describe('å®Œæ•´ç”Ÿæˆæµç¨‹', () => {
    test('åº”è¯¥æˆåŠŸç”Ÿæˆå®Œæ•´é¡¹ç›®', async () => {
      const mockTemplate = {
        files: new Map([
          ['package.json', { 
            content: JSON.stringify({
              name: '{{projectName}}',
              version: '{{version}}',
              description: '{{description}}'
            }, null, 2)
          }],
          ['src/index.ts', { content: 'console.log("Hello {{projectName}}");' }],
          ['.gitignore', { content: 'node_modules/\ndist/' }]
        ]),
        config: null
      };

      mockTemplateManager.getTemplate.mockResolvedValue(mockTemplate);

      // è·³è¿‡ä¾èµ–å®‰è£…å’Œ Git åˆå§‹åŒ–ä»¥ç®€åŒ–æµ‹è¯•
      generator.options.skipInstall = true;
      generator.options.skipGit = true;

      await generator.generate();

      // éªŒè¯æ–‡ä»¶æ˜¯å¦åˆ›å»º
      await TestUtils.assertFileExists(join(generator.targetDir, 'package.json'));
      await TestUtils.assertFileExists(join(generator.targetDir, 'src/index.ts'));
      await TestUtils.assertFileExists(join(generator.targetDir, '.gitignore'));

      // éªŒè¯å˜é‡æ›¿æ¢
      await TestUtils.assertFileContent(
        join(generator.targetDir, 'package.json'),
        '"name": "test-project"'
      );
    });
  });
});
```

### å‘½ä»¤æµ‹è¯•

```javascript
// __tests__/commands/create.test.js
import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { createProject, validateCreateOptions } from '../../lib/commands/create.js';
import { TestUtils } from '../utils/testUtils.js';

describe('create å‘½ä»¤', () => {
  let tempDir;
  let restoreArgs;

  beforeEach(async () => {
    tempDir = await TestUtils.createTempDir('create-test');
    process.chdir(tempDir);
  });

  afterEach(async () => {
    if (restoreArgs) restoreArgs();
    await TestUtils.cleanupTempDir(tempDir);
  });

  describe('å‚æ•°éªŒè¯', () => {
    test('åº”è¯¥éªŒè¯æœ‰æ•ˆçš„é¡¹ç›®åç§°', () => {
      const result = validateCreateOptions('my-project', {});
      expect(result).toBe(true);
    });

    test('åº”è¯¥æ‹’ç»æ— æ•ˆçš„é¡¹ç›®åç§°', () => {
      const result = validateCreateOptions('My Project', {});
      expect(result).toBe(false);
    });

    test('åº”è¯¥æ£€æŸ¥ç›®å½•å†²çª', () => {
      // åˆ›å»ºå·²å­˜åœ¨çš„ç›®å½•
      const existingDir = join(tempDir, 'existing-project');
      mkdirSync(existingDir);

      const result = validateCreateOptions('existing-project', {});
      expect(result).toBe(false);
    });

    test('åº”è¯¥å…è®¸å¼ºåˆ¶è¦†ç›–', () => {
      const existingDir = join(tempDir, 'existing-project');
      mkdirSync(existingDir);

      const result = validateCreateOptions('existing-project', { force: true });
      expect(result).toBe(true);
    });
  });

  describe('é¡¹ç›®åˆ›å»º', () => {
    test('åº”è¯¥åˆ›å»ºåŸºç¡€é¡¹ç›®', async () => {
      const projectName = 'test-project';
      const options = {
        skipInstall: true,
        skipGit: true,
        yes: true
      };

      await createProject(projectName, options);

      expect(existsSync(join(tempDir, projectName))).toBe(true);
      expect(existsSync(join(tempDir, projectName, 'package.json'))).toBe(true);
    });

    test('åº”è¯¥å¤„ç†æ¨¡æ¿é€‰é¡¹', async () => {
      const projectName = 'react-project';
      const options = {
        template: 'react-ts',
        skipInstall: true,
        skipGit: true,
        yes: true
      };

      await createProject(projectName, options);

      const packageJsonPath = join(tempDir, projectName, 'package.json');
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
      
      expect(packageJson.dependencies).toHaveProperty('react');
      expect(packageJson.devDependencies).toHaveProperty('typescript');
    });
  });
});
```

## é›†æˆæµ‹è¯•

### API é›†æˆæµ‹è¯•

```javascript
// __tests__/integration/api.test.js
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { spawn } from 'child_process';
import { TestUtils } from '../utils/testUtils.js';

describe('API é›†æˆæµ‹è¯•', () => {
  let tempDir;

  beforeAll(async () => {
    tempDir = await TestUtils.createTempDir('integration-test');
  });

  afterAll(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  test('å‘½ä»¤è¡Œæ¥å£åº”è¯¥æ­£å¸¸å·¥ä½œ', async () => {
    const result = await runCliCommand(['--version']);
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toMatch(/\d+\.\d+\.\d+/);
  });

  test('åˆ›å»ºå‘½ä»¤åº”è¯¥ç”Ÿæˆå®Œæ•´é¡¹ç›®', async () => {
    const projectName = 'integration-test-project';
    const result = await runCliCommand([
      'create', projectName,
      '--yes',
      '--skip-install',
      '--skip-git'
    ], { cwd: tempDir });

    expect(result.exitCode).toBe(0);
    
    // éªŒè¯é¡¹ç›®æ–‡ä»¶
    const projectPath = join(tempDir, projectName);
    expect(existsSync(join(projectPath, 'package.json'))).toBe(true);
    expect(existsSync(join(projectPath, 'src'))).toBe(true);
  });

  test('æ¨¡æ¿å‘½ä»¤åº”è¯¥åˆ—å‡ºå¯ç”¨æ¨¡æ¿', async () => {
    const result = await runCliCommand(['template', 'list']);
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('react-ts');
    expect(result.stdout).toContain('vue-ts');
  });

  test('é…ç½®å‘½ä»¤åº”è¯¥ç®¡ç†ç”¨æˆ·é…ç½®', async () => {
    // è®¾ç½®é…ç½®
    let result = await runCliCommand(['config', 'set', 'packageManager', 'pnpm']);
    expect(result.exitCode).toBe(0);

    // è·å–é…ç½®
    result = await runCliCommand(['config', 'get', 'packageManager']);
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('pnpm');

    // åˆ é™¤é…ç½®
    result = await runCliCommand(['config', 'delete', 'packageManager']);
    expect(result.exitCode).toBe(0);
  });

  async function runCliCommand(args, options = {}) {
    return new Promise((resolve) => {
      const child = spawn('node', ['../../bin/index.js', ...args], {
        stdio: 'pipe',
        ...options
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (exitCode) => {
        resolve({ exitCode, stdout, stderr });
      });
    });
  }
});
```

## ç«¯åˆ°ç«¯æµ‹è¯•

### E2E æµ‹è¯•æ¡†æ¶

```javascript
// __tests__/e2e/userFlow.test.js
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { TestUtils } from '../utils/testUtils.js';

describe('ç”¨æˆ·å®Œæ•´æµç¨‹æµ‹è¯•', () => {
  let tempDir;

  beforeAll(async () => {
    tempDir = await TestUtils.createTempDir('e2e-test');
  });

  afterAll(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  test('æ–°ç”¨æˆ·åˆ›å»º React é¡¹ç›®çš„å®Œæ•´æµç¨‹', async () => {
    const projectName = 'my-react-app';
    
    // æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®
    const createResult = await TestUtils.runCommand([
      'create', projectName,
      '--template', 'react-ts',
      '--yes',
      '--skip-install' // è·³è¿‡å®‰è£…ä»¥åŠ å¿«æµ‹è¯•
    ], { cwd: tempDir });

    expect(createResult.exitCode).toBe(0);
    expect(createResult.stdout).toContain('é¡¹ç›®åˆ›å»ºæˆåŠŸ');

    // æ­¥éª¤ 2: éªŒè¯é¡¹ç›®ç»“æ„
    const projectPath = join(tempDir, projectName);
    const expectedFiles = [
      'package.json',
      'tsconfig.json',
      'src/App.tsx',
      'src/main.tsx',
      'index.html',
      'vite.config.ts'
    ];

    for (const file of expectedFiles) {
      expect(existsSync(join(projectPath, file))).toBe(true);
    }

    // æ­¥éª¤ 3: éªŒè¯ package.json å†…å®¹
    const packageJson = JSON.parse(
      readFileSync(join(projectPath, 'package.json'), 'utf8')
    );
    
    expect(packageJson.name).toBe(projectName);
    expect(packageJson.dependencies).toHaveProperty('react');
    expect(packageJson.devDependencies).toHaveProperty('typescript');
    expect(packageJson.devDependencies).toHaveProperty('vite');

    // æ­¥éª¤ 4: éªŒè¯ TypeScript é…ç½®
    const tsConfig = JSON.parse(
      readFileSync(join(projectPath, 'tsconfig.json'), 'utf8')
    );
    
    expect(tsConfig.compilerOptions.target).toBe('ES2020');
    expect(tsConfig.compilerOptions.jsx).toBe('react-jsx');
  });

  test('ç”¨æˆ·è‡ªå®šä¹‰é¡¹ç›®é…ç½®æµç¨‹', async () => {
    const projectName = 'custom-project';
    
    // ä½¿ç”¨äº¤äº’å¼åˆ›å»ºï¼ˆæ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥ï¼‰
    const createResult = await TestUtils.runCommandWithInput([
      'create', projectName
    ], [
      'vue',           // é€‰æ‹© Vue æ¡†æ¶
      'true',          // ä½¿ç”¨ TypeScript
      'pnpm',          // é€‰æ‹© pnpm
      'true',          // åˆå§‹åŒ– Git
      'false'          // ä¸ç«‹å³å®‰è£…ä¾èµ–
    ], { cwd: tempDir });

    expect(createResult.exitCode).toBe(0);

    // éªŒè¯ç”Ÿæˆçš„é¡¹ç›®
    const projectPath = join(tempDir, projectName);
    const packageJson = JSON.parse(
      readFileSync(join(projectPath, 'package.json'), 'utf8')
    );

    expect(packageJson.dependencies).toHaveProperty('vue');
    expect(packageJson.devDependencies).toHaveProperty('typescript');
  });

  test('é”™è¯¯å¤„ç†å’Œæ¢å¤æµç¨‹', async () => {
    // æµ‹è¯•æ— æ•ˆé¡¹ç›®åç§°
    const invalidResult = await TestUtils.runCommand([
      'create', 'Invalid Project Name!'
    ], { cwd: tempDir });

    expect(invalidResult.exitCode).toBe(1);
    expect(invalidResult.stderr).toContain('é¡¹ç›®åç§°ä¸åˆæ³•');

    // æµ‹è¯•ç›®å½•å†²çª
    const existingDir = join(tempDir, 'existing-project');
    mkdirSync(existingDir);

    const conflictResult = await TestUtils.runCommand([
      'create', 'existing-project'
    ], { cwd: tempDir });

    expect(conflictResult.exitCode).toBe(1);
    expect(conflictResult.stderr).toContain('ç›®å½•å·²å­˜åœ¨');

    // æµ‹è¯•å¼ºåˆ¶è¦†ç›–
    const forceResult = await TestUtils.runCommand([
      'create', 'existing-project',
      '--force',
      '--yes',
      '--skip-install',
      '--skip-git'
    ], { cwd: tempDir });

    expect(forceResult.exitCode).toBe(0);
  });
});
```

## CI/CD æµæ°´çº¿é…ç½®

### GitHub Actions é…ç½®

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '18'

jobs:
  test:
    name: Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16, 18, 20]

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Run security audit
        run: npm audit --audit-level=high

      - name: Run dependency scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, security]
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build package
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: dist/

  publish:
    name: Publish to NPM
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: github.event_name == 'release'
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci

      - name: Build package
        run: npm run build

      - name: Publish to NPM
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub release notes
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
```

### å‘å¸ƒå‰æ£€æŸ¥è„šæœ¬

```javascript
// scripts/pre-publish.js
import { readFile, writeFile } from 'fs/promises';
import { execSync } from 'child_process';
import chalk from 'chalk';

async function prePublishChecks() {
  console.log(chalk.blue('ğŸ” æ‰§è¡Œå‘å¸ƒå‰æ£€æŸ¥...'));

  try {
    // æ£€æŸ¥ 1: éªŒè¯ package.json
    await validatePackageJson();
    
    // æ£€æŸ¥ 2: è¿è¡Œæ‰€æœ‰æµ‹è¯•
    await runTests();
    
    // æ£€æŸ¥ 3: æ£€æŸ¥ä»£ç è´¨é‡
    await checkCodeQuality();
    
    // æ£€æŸ¥ 4: éªŒè¯æ„å»º
    await validateBuild();
    
    // æ£€æŸ¥ 5: æ£€æŸ¥ç‰ˆæœ¬å·
    await checkVersion();
    
    // æ£€æŸ¥ 6: ç”Ÿæˆå˜æ›´æ—¥å¿—
    await generateChangelog();

    console.log(chalk.green('âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œå¯ä»¥å‘å¸ƒï¼'));
    
  } catch (error) {
    console.error(chalk.red('âŒ å‘å¸ƒå‰æ£€æŸ¥å¤±è´¥:'), error.message);
    process.exit(1);
  }
}

async function validatePackageJson() {
  console.log(chalk.gray('ğŸ“¦ éªŒè¯ package.json...'));
  
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  
  // å¿…éœ€å­—æ®µæ£€æŸ¥
  const requiredFields = ['name', 'version', 'description', 'main', 'bin'];
  for (const field of requiredFields) {
    if (!packageJson[field]) {
      throw new Error(`package.json ç¼ºå°‘å¿…éœ€å­—æ®µ: ${field}`);
    }
  }
  
  // å…³é”®è¯æ£€æŸ¥
  if (!packageJson.keywords || packageJson.keywords.length === 0) {
    throw new Error('package.json ç¼ºå°‘å…³é”®è¯');
  }
  
  // ä»“åº“ä¿¡æ¯æ£€æŸ¥
  if (!packageJson.repository) {
    throw new Error('package.json ç¼ºå°‘ä»“åº“ä¿¡æ¯');
  }
}

async function runTests() {
  console.log(chalk.gray('ğŸ§ª è¿è¡Œæµ‹è¯•å¥—ä»¶...'));
  
  try {
    execSync('npm run test:all', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('æµ‹è¯•å¤±è´¥');
  }
}

async function checkCodeQuality() {
  console.log(chalk.gray('ğŸ” æ£€æŸ¥ä»£ç è´¨é‡...'));
  
  try {
    execSync('npm run lint', { stdio: 'inherit' });
    execSync('npm run type-check', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('ä»£ç è´¨é‡æ£€æŸ¥å¤±è´¥');
  }
}

async function validateBuild() {
  console.log(chalk.gray('ğŸ—ï¸ éªŒè¯æ„å»º...'));
  
  try {
    execSync('npm run build', { stdio: 'inherit' });
  } catch (error) {
    throw new Error('æ„å»ºå¤±è´¥');
  }
}

async function checkVersion() {
  console.log(chalk.gray('ğŸ“‹ æ£€æŸ¥ç‰ˆæœ¬å·...'));
  
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  const currentVersion = packageJson.version;
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„è¯­ä¹‰åŒ–ç‰ˆæœ¬
  const semverRegex = /^\d+\.\d+\.\d+(-[a-zA-Z0-9-]+)?$/;
  if (!semverRegex.test(currentVersion)) {
    throw new Error(`æ— æ•ˆçš„ç‰ˆæœ¬å·: ${currentVersion}`);
  }
  
  // æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦å·²å‘å¸ƒ
  try {
    const publishedVersions = execSync(
      `npm view ${packageJson.name} versions --json`,
      { encoding: 'utf8' }
    );
    
    const versions = JSON.parse(publishedVersions);
    if (versions.includes(currentVersion)) {
      throw new Error(`ç‰ˆæœ¬ ${currentVersion} å·²ç»å‘å¸ƒ`);
    }
  } catch (error) {
    // å¦‚æœåŒ…è¿˜æ²¡æœ‰å‘å¸ƒï¼Œè¿™æ˜¯æ­£å¸¸çš„
    if (!error.message.includes('404')) {
      throw error;
    }
  }
}

async function generateChangelog() {
  console.log(chalk.gray('ğŸ“ ç”Ÿæˆå˜æ›´æ—¥å¿—...'));
  
  try {
    execSync('npx conventional-changelog -p angular -i CHANGELOG.md -s', {
      stdio: 'inherit'
    });
  } catch (error) {
    console.warn(chalk.yellow('âš ï¸ å˜æ›´æ—¥å¿—ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ›´æ–°'));
  }
}

prePublishChecks();
```

## NPM åŒ…å‘å¸ƒ

### å‘å¸ƒé…ç½®

```json
{
  "scripts": {
    "prepublishOnly": "node scripts/pre-publish.js",
    "postpublish": "node scripts/post-publish.js"
  },
  "files": [
    "bin/",
    "lib/",
    "README.md",
    "LICENSE"
  ],
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  }
}
```

### ç‰ˆæœ¬ç®¡ç†è„šæœ¬

```javascript
// scripts/release.js
import inquirer from 'inquirer';
import { execSync } from 'child_process';
import chalk from 'chalk';

async function release() {
  console.log(chalk.blue('ğŸš€ å¼€å§‹å‘å¸ƒæµç¨‹...'));

  try {
    // 1. é€‰æ‹©ç‰ˆæœ¬ç±»å‹
    const { versionType } = await inquirer.prompt([
      {
        type: 'list',
        name: 'versionType',
        message: 'é€‰æ‹©ç‰ˆæœ¬ç±»å‹:',
        choices: [
          { name: 'patch (bug ä¿®å¤)', value: 'patch' },
          { name: 'minor (æ–°åŠŸèƒ½)', value: 'minor' },
          { name: 'major (ç ´åæ€§å˜æ›´)', value: 'major' },
          { name: 'prerelease (é¢„å‘å¸ƒ)', value: 'prerelease' },
          { name: 'custom (è‡ªå®šä¹‰)', value: 'custom' }
        ]
      }
    ]);

    let newVersion;
    if (versionType === 'custom') {
      const { customVersion } = await inquirer.prompt([
        {
          type: 'input',
          name: 'customVersion',
          message: 'è¾“å…¥ç‰ˆæœ¬å·:',
          validate: (input) => {
            const semverRegex = /^\d+\.\d+\.\d+(-[a-zA-Z0-9-]+)?$/;
            return semverRegex.test(input) || 'è¯·è¾“å…¥æœ‰æ•ˆçš„è¯­ä¹‰åŒ–ç‰ˆæœ¬å·';
          }
        }
      ]);
      newVersion = customVersion;
    } else {
      // ä½¿ç”¨ npm version è‡ªåŠ¨é€’å¢
      newVersion = execSync(`npm version ${versionType} --no-git-tag-version`, {
        encoding: 'utf8'
      }).trim();
    }

    console.log(chalk.green(`æ–°ç‰ˆæœ¬: ${newVersion}`));

    // 2. ç¡®è®¤å‘å¸ƒ
    const { confirmPublish } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirmPublish',
        message: `ç¡®è®¤å‘å¸ƒç‰ˆæœ¬ ${newVersion}?`,
        default: false
      }
    ]);

    if (!confirmPublish) {
      console.log(chalk.yellow('å‘å¸ƒå·²å–æ¶ˆ'));
      return;
    }

    // 3. æäº¤ç‰ˆæœ¬å˜æ›´
    execSync(`git add package.json package-lock.json`);
    execSync(`git commit -m "chore: release ${newVersion}"`);
    execSync(`git tag ${newVersion}`);

    // 4. æ¨é€åˆ°è¿œç¨‹ä»“åº“
    execSync('git push origin main --follow-tags');

    // 5. å‘å¸ƒåˆ° NPM
    execSync('npm publish');

    console.log(chalk.green(`ğŸ‰ ç‰ˆæœ¬ ${newVersion} å‘å¸ƒæˆåŠŸï¼`));

  } catch (error) {
    console.error(chalk.red('å‘å¸ƒå¤±è´¥:'), error.message);
    process.exit(1);
  }
}

release();
```

## æ€»ç»“

æœ¬æ–‡è¯¦ç»†ä»‹ç»äº† TerraFE çš„å®Œæ•´æµ‹è¯•å’Œå‘å¸ƒæµç¨‹ï¼š

1. **æµ‹è¯•ç­–ç•¥**ï¼šå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•çš„å®Œæ•´è¦†ç›–
2. **CI/CD æµæ°´çº¿**ï¼šè‡ªåŠ¨åŒ–çš„æµ‹è¯•ã€æ„å»ºå’Œå‘å¸ƒæµç¨‹
3. **è´¨é‡ä¿è¯**ï¼šä»£ç è´¨é‡æ£€æŸ¥ã€å®‰å…¨æ‰«æã€è¦†ç›–ç‡ç›‘æ§
4. **å‘å¸ƒç®¡ç†**ï¼šç‰ˆæœ¬æ§åˆ¶ã€å˜æ›´æ—¥å¿—ã€å‘å¸ƒæ£€æŸ¥

è¿™å¥—å®Œæ•´çš„è´¨é‡ä¿è¯ä½“ç³»ç¡®ä¿äº† TerraFE çš„ç¨³å®šæ€§å’Œå¯é æ€§ï¼Œä¸ºç”¨æˆ·æä¾›é«˜è´¨é‡çš„å¼€å‘å·¥å…·ã€‚

## ç³»åˆ—æ€»ç»“

é€šè¿‡è¿™ä¸ƒç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬å®Œæ•´åœ°ä»‹ç»äº† TerraFE è„šæ‰‹æ¶å·¥å…·çš„å¼€å‘å…¨è¿‡ç¨‹ï¼š

1. **æ¶æ„è®¾è®¡ä¸æŠ€æœ¯é€‰å‹**ï¼šå¥ å®šäº†é¡¹ç›®çš„æŠ€æœ¯åŸºç¡€
2. **CLI å·¥å…·åŸºç¡€æ­å»º**ï¼šå»ºç«‹äº†å‘½ä»¤è¡Œæ¡†æ¶
3. **å‘½ä»¤è¡Œäº¤äº’ä¸å‚æ•°å¤„ç†**ï¼šå®ç°äº†ç”¨æˆ·å‹å¥½çš„äº¤äº’
4. **æ¨¡æ¿ç³»ç»Ÿè®¾è®¡ä¸å®ç°**ï¼šæ„å»ºäº†çµæ´»çš„æ¨¡æ¿ç®¡ç†
5. **æ–‡ä»¶æ“ä½œä¸é¡¹ç›®ç”Ÿæˆ**ï¼šå®Œæˆäº†æ ¸å¿ƒåŠŸèƒ½å®ç°
6. **é”™è¯¯å¤„ç†ä¸ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼šæå‡äº†å·¥å…·çš„å¯ç”¨æ€§
7. **æµ‹è¯•ä¸å‘å¸ƒ**ï¼šä¿è¯äº†äº§å“è´¨é‡

å¸Œæœ›è¿™ä¸ªç³»åˆ—èƒ½å¤Ÿä¸ºæƒ³è¦å¼€å‘ CLI å·¥å…·çš„å¼€å‘è€…æä¾›å®Œæ•´çš„å‚è€ƒå’ŒæŒ‡å¯¼ï¼

---

*æ„Ÿè°¢æ‚¨è·Ÿéšè¿™ä¸ªç³»åˆ—åˆ°æœ€åï¼å¦‚æœå¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµã€è½¬å‘å’Œå…³æ³¨ã€‚* 