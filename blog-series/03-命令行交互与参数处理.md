# TerraFE 脚手架开发实战系列（三）：命令行交互与参数处理

## 前言

在前两篇文章中，我们完成了项目架构设计和 CLI 基础框架搭建。本文将深入探讨如何使用 Inquirer.js 创建优雅的交互式命令行界面，以及如何处理复杂的参数验证和转换逻辑。

## Inquirer.js 深度解析

### 核心概念

Inquirer.js 是一个强大的命令行交互库，提供了多种问题类型和灵活的配置选项。

### 问题类型详解

#### 1. 单选列表 (list)

```javascript
{
  type: 'list',
  name: 'framework',
  message: '请选择前端框架:',
  choices: [
    { name: 'React', value: 'react' },
    { name: 'Vue 3', value: 'vue' },
    { name: 'Angular', value: 'angular' },
    { name: 'Svelte', value: 'svelte' }
  ],
  default: 'react'
}
```

#### 2. 多选列表 (checkbox)

```javascript
{
  type: 'checkbox',
  name: 'features',
  message: '请选择需要的功能:',
  choices: [
    { name: 'TypeScript', value: 'typescript', checked: true },
    { name: 'ESLint', value: 'eslint', checked: true },
    { name: 'Prettier', value: 'prettier', checked: true },
    { name: 'Jest', value: 'jest' },
    { name: 'PWA', value: 'pwa' }
  ]
}
```

#### 3. 确认选择 (confirm)

```javascript
{
  type: 'confirm',
  name: 'useTypeScript',
  message: '是否使用 TypeScript?',
  default: true
}
```

#### 4. 文本输入 (input)

```javascript
{
  type: 'input',
  name: 'author',
  message: '请输入作者姓名:',
  default: () => {
    // 从 git config 获取默认值
    return process.env.USER || 'Anonymous';
  },
  validate: (input) => {
    return input.length > 0 || '作者姓名不能为空';
  }
}
```

#### 5. 密码输入 (password)

```javascript
{
  type: 'password',
  name: 'token',
  message: '请输入 GitHub Token:',
  mask: '*'
}
```

### 高级特性

#### 1. 条件显示 (when)

```javascript
{
  type: 'input',
  name: 'customTemplate',
  message: '请输入自定义模板 URL:',
  when: (answers) => answers.templateSource === 'custom',
  validate: (input) => {
    return validateUrl(input).valid || '请输入有效的 URL';
  }
}
```

#### 2. 动态选择 (choices function)

```javascript
{
  type: 'list',
  name: 'template',
  message: '请选择模板:',
  choices: async (answers) => {
    const templates = await getTemplatesByFramework(answers.framework);
    return templates.map(t => ({
      name: `${t.name} - ${t.description}`,
      value: t.id
    }));
  }
}
```

#### 3. 自定义验证

```javascript
{
  type: 'input',
  name: 'projectName',
  message: '请输入项目名称:',
  validate: async (input) => {
    // 异步验证
    const validation = validateProjectName(input);
    if (!validation.valid) {
      return validation.message;
    }
    
    // 检查是否已存在
    const exists = await checkProjectExists(input);
    if (exists) {
      return '项目名称已存在，请选择其他名称';
    }
    
    return true;
  },
  filter: (input) => {
    // 转换输入
    return input.toLowerCase().replace(/\s+/g, '-');
  }
}
```

## 实际交互流程实现

### 完整的交互式项目创建

```javascript
// lib/prompts/createPrompts.js
import inquirer from 'inquirer';
import chalk from 'chalk';
import { existsSync } from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';

import { validateProjectName, validateUrl } from '../utils/validate.js';
import { getAvailableTemplates } from '../core/Template.js';
import { detectPackageManager } from '../utils/packageManager.js';

const execAsync = promisify(exec);

/**
 * 主要的项目创建提示流程
 */
export async function createProjectPrompts(projectName, options) {
  const prompts = [];

  // 项目基本信息
  if (!options.yes) {
    prompts.push(...await getBasicInfoPrompts(projectName, options));
    prompts.push(...await getTemplatePrompts(options));
    prompts.push(...await getConfigurationPrompts(options));
    prompts.push(...await getPostInstallPrompts(options));
  }

  return await inquirer.prompt(prompts);
}

/**
 * 基本信息提示
 */
async function getBasicInfoPrompts(projectName, options) {
  const prompts = [];

  // 项目描述
  if (!options.description) {
    prompts.push({
      type: 'input',
      name: 'description',
      message: '请输入项目描述:',
      default: `A project created with TerraFE`
    });
  }

  // 作者信息
  if (!options.author) {
    const defaultAuthor = await getDefaultAuthor();
    prompts.push({
      type: 'input',
      name: 'author',
      message: '请输入作者信息:',
      default: defaultAuthor,
      validate: (input) => input.length > 0 || '作者信息不能为空'
    });
  }

  // 版本号
  if (!options.version) {
    prompts.push({
      type: 'input',
      name: 'version',
      message: '请输入初始版本号:',
      default: '1.0.0',
      validate: (input) => {
        const semverRegex = /^\d+\.\d+\.\d+$/;
        return semverRegex.test(input) || '请输入有效的语义化版本号 (如: 1.0.0)';
      }
    });
  }

  // 许可证
  if (!options.license) {
    prompts.push({
      type: 'list',
      name: 'license',
      message: '请选择许可证:',
      choices: [
        { name: 'MIT', value: 'MIT' },
        { name: 'Apache-2.0', value: 'Apache-2.0' },
        { name: 'GPL-3.0', value: 'GPL-3.0' },
        { name: 'ISC', value: 'ISC' },
        { name: 'BSD-3-Clause', value: 'BSD-3-Clause' },
        { name: 'Unlicense', value: 'Unlicense' }
      ],
      default: 'MIT'
    });
  }

  return prompts;
}

/**
 * 模板选择提示
 */
async function getTemplatePrompts(options) {
  const prompts = [];

  // 模板来源
  if (!options.template && !options.repo) {
    prompts.push({
      type: 'list',
      name: 'templateSource',
      message: '请选择模板来源:',
      choices: [
        { name: '官方模板', value: 'official' },
        { name: 'GitHub 仓库', value: 'github' },
        { name: '本地模板', value: 'local' }
      ],
      default: 'official'
    });

    // 官方模板选择
    prompts.push({
      type: 'list',
      name: 'framework',
      message: '请选择前端框架:',
      when: (answers) => answers.templateSource === 'official',
      choices: [
        { name: 'React', value: 'react' },
        { name: 'Vue 3', value: 'vue' },
        { name: 'Angular', value: 'angular' },
        { name: 'Svelte', value: 'svelte' },
        { name: 'Vanilla JS', value: 'vanilla' }
      ]
    });

    // 具体模板选择
    prompts.push({
      type: 'list',
      name: 'template',
      message: '请选择具体模板:',
      when: (answers) => answers.templateSource === 'official' && answers.framework,
      choices: async (answers) => {
        const templates = await getAvailableTemplates(answers.framework);
        return templates.map(t => ({
          name: `${t.name} - ${chalk.gray(t.description)}`,
          value: t.id
        }));
      }
    });

    // GitHub 仓库输入
    prompts.push({
      type: 'input',
      name: 'githubRepo',
      message: '请输入 GitHub 仓库 (owner/repo):',
      when: (answers) => answers.templateSource === 'github',
      validate: (input) => {
        const validation = validateGitHubRepo(input);
        return validation.valid || validation.message;
      }
    });

    // 本地模板路径
    prompts.push({
      type: 'input',
      name: 'localPath',
      message: '请输入本地模板路径:',
      when: (answers) => answers.templateSource === 'local',
      validate: (input) => {
        return existsSync(input) || '路径不存在';
      }
    });
  }

  return prompts;
}

/**
 * 配置选择提示
 */
async function getConfigurationPrompts(options) {
  const prompts = [];

  // TypeScript 支持
  prompts.push({
    type: 'confirm',
    name: 'typescript',
    message: '是否使用 TypeScript?',
    default: true,
    when: (answers) => {
      // 某些模板已经包含 TypeScript，无需询问
      return !isTypescriptTemplate(answers.template);
    }
  });

  // 包管理器选择
  if (!options.packageManager) {
    const availableManagers = await detectAvailablePackageManagers();
    prompts.push({
      type: 'list',
      name: 'packageManager',
      message: '请选择包管理器:',
      choices: availableManagers.map(pm => ({
        name: `${pm.name} ${chalk.gray(pm.version ? `(${pm.version})` : '')}`,
        value: pm.name
      })),
      default: getRecommendedPackageManager(availableManagers)
    });
  }

  // 代码质量工具
  prompts.push({
    type: 'checkbox',
    name: 'tools',
    message: '请选择需要的代码质量工具:',
    choices: [
      { name: 'ESLint', value: 'eslint', checked: true },
      { name: 'Prettier', value: 'prettier', checked: true },
      { name: 'Husky (Git Hooks)', value: 'husky' },
      { name: 'lint-staged', value: 'lint-staged' },
      { name: 'Commitizen', value: 'commitizen' }
    ]
  });

  // CSS 预处理器
  prompts.push({
    type: 'list',
    name: 'cssPreprocessor',
    message: '请选择 CSS 预处理器:',
    choices: [
      { name: '无', value: 'none' },
      { name: 'Sass/SCSS', value: 'sass' },
      { name: 'Less', value: 'less' },
      { name: 'Stylus', value: 'stylus' },
      { name: 'PostCSS', value: 'postcss' }
    ],
    default: 'none'
  });

  return prompts;
}

/**
 * 安装后操作提示
 */
async function getPostInstallPrompts(options) {
  const prompts = [];

  // Git 初始化
  if (!options.skipGit) {
    prompts.push({
      type: 'confirm',
      name: 'initGit',
      message: '是否初始化 Git 仓库?',
      default: true
    });

    // 首次提交
    prompts.push({
      type: 'confirm',
      name: 'initialCommit',
      message: '是否创建初始提交?',
      default: true,
      when: (answers) => answers.initGit
    });
  }

  // 依赖安装
  if (!options.skipInstall) {
    prompts.push({
      type: 'confirm',
      name: 'installDeps',
      message: '是否立即安装依赖?',
      default: true
    });
  }

  // 启动开发服务器
  prompts.push({
    type: 'confirm',
    name: 'startDev',
    message: '是否在完成后启动开发服务器?',
    default: false,
    when: (answers) => answers.installDeps
  });

  return prompts;
}

/**
 * 获取默认作者信息
 */
async function getDefaultAuthor() {
  try {
    const { stdout: name } = await execAsync('git config user.name');
    const { stdout: email } = await execAsync('git config user.email');
    
    const userName = name.trim();
    const userEmail = email.trim();
    
    if (userName && userEmail) {
      return `${userName} <${userEmail}>`;
    } else if (userName) {
      return userName;
    }
  } catch {
    // Git 未配置或不可用
  }
  
  return process.env.USER || 'Anonymous';
}

/**
 * 检测可用的包管理器
 */
async function detectAvailablePackageManagers() {
  const managers = [
    { name: 'pnpm', command: 'pnpm --version' },
    { name: 'yarn', command: 'yarn --version' },
    { name: 'npm', command: 'npm --version' }
  ];

  const available = [];

  for (const manager of managers) {
    try {
      const { stdout } = await execAsync(manager.command);
      available.push({
        name: manager.name,
        version: stdout.trim()
      });
    } catch {
      // 包管理器不可用
    }
  }

  return available;
}

/**
 * 获取推荐的包管理器
 */
function getRecommendedPackageManager(available) {
  const priority = ['pnpm', 'yarn', 'npm'];
  
  for (const pm of priority) {
    if (available.find(a => a.name === pm)) {
      return pm;
    }
  }
  
  return available[0]?.name || 'npm';
}

/**
 * 检查是否为 TypeScript 模板
 */
function isTypescriptTemplate(templateId) {
  return templateId && templateId.includes('ts');
}
```

## 参数验证与转换

### 复杂验证逻辑

```javascript
// lib/utils/validation.js
import { existsSync, statSync } from 'fs';
import { resolve } from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * 项目名称验证器
 */
export class ProjectNameValidator {
  static async validate(name, targetDir) {
    const errors = [];

    // 基础格式验证
    if (!name || name.length === 0) {
      errors.push('项目名称不能为空');
    }

    if (name.length > 214) {
      errors.push('项目名称长度不能超过 214 个字符');
    }

    if (name.toLowerCase() !== name) {
      errors.push('项目名称应该使用小写字母');
    }

    if (!/^[a-z0-9-_]+$/.test(name)) {
      errors.push('项目名称只能包含小写字母、数字、连字符和下划线');
    }

    if (name.startsWith('.') || name.startsWith('-') || name.startsWith('_')) {
      errors.push('项目名称不能以特殊字符开头');
    }

    // NPM 包名验证
    const npmValidation = validateNpmPackageName(name);
    if (!npmValidation.validForNewPackages) {
      errors.push(...(npmValidation.errors || []));
    }

    // 目录冲突检查
    if (targetDir && existsSync(targetDir)) {
      const stat = statSync(targetDir);
      if (stat.isDirectory()) {
        const files = await fs.readdir(targetDir);
        if (files.length > 0) {
          errors.push('目标目录不为空');
        }
      } else {
        errors.push('目标路径已存在且不是目录');
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}

/**
 * GitHub 仓库验证器
 */
export class GitHubRepoValidator {
  static async validate(repo) {
    const errors = [];

    // 格式验证
    const pattern = /^([a-zA-Z0-9._-]+)\/([a-zA-Z0-9._-]+)$/;
    const match = repo.match(pattern);

    if (!match) {
      errors.push('仓库格式应为 owner/repo');
      return { valid: false, errors };
    }

    const [, owner, repoName] = match;

    // 长度验证
    if (owner.length > 39) {
      errors.push('用户名长度不能超过 39 个字符');
    }

    if (repoName.length > 100) {
      errors.push('仓库名长度不能超过 100 个字符');
    }

    // 在线验证（可选）
    try {
      const response = await fetch(`https://api.github.com/repos/${repo}`);
      if (!response.ok) {
        if (response.status === 404) {
          errors.push('仓库不存在或无法访问');
        } else {
          errors.push('无法验证仓库状态');
        }
      }
    } catch {
      // 网络错误，跳过在线验证
    }

    return {
      valid: errors.length === 0,
      errors,
      owner,
      repo: repoName
    };
  }
}

/**
 * 模板路径验证器
 */
export class TemplatePathValidator {
  static async validate(templatePath) {
    const errors = [];
    const resolvedPath = resolve(templatePath);

    // 路径存在性检查
    if (!existsSync(resolvedPath)) {
      errors.push('模板路径不存在');
      return { valid: false, errors };
    }

    // 目录检查
    const stat = statSync(resolvedPath);
    if (!stat.isDirectory()) {
      errors.push('模板路径必须是目录');
      return { valid: false, errors };
    }

    // 模板有效性检查
    const requiredFiles = ['package.json'];
    const optionalFiles = ['terrafe.config.js', 'template.json'];

    for (const file of requiredFiles) {
      const filePath = resolve(resolvedPath, file);
      if (!existsSync(filePath)) {
        errors.push(`缺少必需文件: ${file}`);
      }
    }

    // 检查是否为有效的 TerraFE 模板
    const configPath = resolve(resolvedPath, 'terrafe.config.js');
    if (existsSync(configPath)) {
      try {
        const config = await import(configPath);
        if (!config.default && !config.prompts) {
          errors.push('无效的 TerraFE 模板配置');
        }
      } catch (error) {
        errors.push(`模板配置文件解析失败: ${error.message}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      path: resolvedPath
    };
  }
}
```

## 用户体验优化

### 进度指示和加载动画

```javascript
// lib/utils/progress.js
import ora from 'ora';
import chalk from 'chalk';

export class ProgressManager {
  constructor() {
    this.spinner = null;
    this.steps = [];
    this.currentStep = 0;
  }

  setSteps(steps) {
    this.steps = steps;
    this.currentStep = 0;
  }

  start(message) {
    this.spinner = ora({
      text: message,
      color: 'cyan'
    }).start();
  }

  updateStep(stepIndex, status = 'running') {
    if (stepIndex < this.steps.length) {
      this.currentStep = stepIndex;
      const step = this.steps[stepIndex];
      
      let icon = '⏳';
      let color = 'cyan';
      
      switch (status) {
        case 'completed':
          icon = '✅';
          color = 'green';
          break;
        case 'failed':
          icon = '❌';
          color = 'red';
          break;
        case 'running':
          icon = '⏳';
          color = 'cyan';
          break;
      }

      const text = `${icon} ${step.name}`;
      
      if (this.spinner) {
        this.spinner.text = chalk[color](text);
      }
    }
  }

  succeed(message) {
    if (this.spinner) {
      this.spinner.succeed(chalk.green(message));
      this.spinner = null;
    }
  }

  fail(message) {
    if (this.spinner) {
      this.spinner.fail(chalk.red(message));
      this.spinner = null;
    }
  }

  info(message) {
    if (this.spinner) {
      this.spinner.info(chalk.blue(message));
      this.spinner = null;
    }
  }

  warn(message) {
    if (this.spinner) {
      this.spinner.warn(chalk.yellow(message));
      this.spinner = null;
    }
  }
}

// 使用示例
export async function createProjectWithProgress(projectName, options) {
  const progress = new ProgressManager();
  
  const steps = [
    { name: '验证项目配置' },
    { name: '下载模板' },
    { name: '处理模板文件' },
    { name: '安装依赖' },
    { name: '初始化 Git' },
    { name: '完成项目创建' }
  ];

  progress.setSteps(steps);

  try {
    // 步骤 1: 验证配置
    progress.updateStep(0, 'running');
    await validateProjectConfig(projectName, options);
    progress.updateStep(0, 'completed');

    // 步骤 2: 下载模板
    progress.updateStep(1, 'running');
    const template = await downloadTemplate(options);
    progress.updateStep(1, 'completed');

    // 步骤 3: 处理模板
    progress.updateStep(2, 'running');
    await processTemplate(template, projectName, options);
    progress.updateStep(2, 'completed');

    // 步骤 4: 安装依赖
    if (options.installDeps) {
      progress.updateStep(3, 'running');
      await installDependencies(projectName, options.packageManager);
      progress.updateStep(3, 'completed');
    }

    // 步骤 5: 初始化 Git
    if (options.initGit) {
      progress.updateStep(4, 'running');
      await initializeGit(projectName, options);
      progress.updateStep(4, 'completed');
    }

    // 完成
    progress.updateStep(5, 'completed');
    progress.succeed(`项目 ${chalk.cyan(projectName)} 创建成功！`);

  } catch (error) {
    progress.fail(`项目创建失败: ${error.message}`);
    throw error;
  }
}
```

### 智能提示和自动补全

```javascript
// lib/utils/suggestions.js
export class SuggestionEngine {
  static suggestProjectName(input) {
    const suggestions = [];
    
    if (!input) {
      return ['my-app', 'awesome-project', 'hello-world'];
    }

    // 修复常见问题
    let fixed = input.toLowerCase()
      .replace(/\s+/g, '-')           // 空格转连字符
      .replace(/[^a-z0-9-_]/g, '')   // 移除无效字符
      .replace(/^[-_]+/, '')          // 移除开头的特殊字符
      .replace(/[-_]+$/, '');         // 移除结尾的特殊字符

    if (fixed !== input) {
      suggestions.push(fixed);
    }

    // 添加常见后缀
    const suffixes = ['app', 'project', 'web', 'ui'];
    suffixes.forEach(suffix => {
      if (!fixed.includes(suffix)) {
        suggestions.push(`${fixed}-${suffix}`);
      }
    });

    return suggestions.slice(0, 3);
  }

  static suggestAuthor(gitConfig) {
    const suggestions = [];
    
    if (gitConfig.name && gitConfig.email) {
      suggestions.push(`${gitConfig.name} <${gitConfig.email}>`);
      suggestions.push(gitConfig.name);
    }

    suggestions.push(process.env.USER || 'Anonymous');
    
    return suggestions;
  }

  static suggestLicense(projectType) {
    const licenses = {
      library: ['MIT', 'Apache-2.0', 'BSD-3-Clause'],
      application: ['MIT', 'GPL-3.0', 'Apache-2.0'],
      commercial: ['MIT', 'Apache-2.0', 'Proprietary']
    };

    return licenses[projectType] || licenses.application;
  }
}
```

## 总结

本文深入探讨了命令行交互与参数处理的各个方面：

1. **Inquirer.js 高级用法**：各种问题类型、条件显示、动态选择
2. **复杂验证逻辑**：项目名称、GitHub 仓库、模板路径验证
3. **用户体验优化**：进度指示、智能提示、错误恢复
4. **参数转换和处理**：输入规范化、默认值生成

这些技术确保了 TerraFE 脚手架工具能够提供流畅、智能的用户体验。

## 下期预告

**《TerraFE 脚手架开发实战系列（四）：模板系统设计与实现》**

- 模板下载和缓存机制
- 变量替换引擎
- 模板配置系统
- 插件式模板扩展

---

*如果这篇文章对你有帮助，欢迎点赞和转发。有任何问题或建议，欢迎在评论区讨论！* 